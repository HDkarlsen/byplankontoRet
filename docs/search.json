[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R for Byplankontoret",
    "section": "",
    "text": "Dette er en pamflett skrevet for Byplankontorets statistikere, for å gi en kort introduksjon til R, samt dokumentere arbeidet jeg har gjort i R. Teksten er skrevet i Quarto ved hjelp av bookdown.\nSe intro for mer info om hva pamfletten inneholder. Eller hopp rett til et kapittel, på eget ansvar."
  },
  {
    "objectID": "index.html#status",
    "href": "index.html#status",
    "title": "R for Byplankontoret",
    "section": "Status",
    "text": "Status\nDette er strengt et et pågående arbeidsprosjekt. Det er mange ting jeg ikke har rukket. Dette vil vises tydeligst i mengden skrivefeil som florerer blant disse digitale sider. Se på det som en tålmodighetsprøve. Det har helt sikkert greid å snike seg inn andre feil også her og der."
  },
  {
    "objectID": "intro.html#tidshorisont",
    "href": "intro.html#tidshorisont",
    "title": "1  Introduksjon",
    "section": "1.1 Tidshorisont",
    "text": "1.1 Tidshorisont\nDenne dokumentasjonen blei til i mars 2023. Koden forventes å kunne kjøres uten problemer en stund framover. Som jeg nevner i Section 2.4 vil kanskje framtidige versjoner av R og tidyverse gjøre endringer som påvirker koden min her. Om dere får tak i samme versjon av R og tidyverse vil dere unngå eventuelle problemer forbundet med dette.\n\nLykke til!\nHåvard\n2023-03-31"
  },
  {
    "objectID": "omR.html#spss",
    "href": "omR.html#spss",
    "title": "2  Om R",
    "section": "2.1 SPSS",
    "text": "2.1 SPSS\nR er mest likt SPSS, og spesielt SPSS’ syntaks. Til forskjell fra SPSS er ikke det grafiske brukergrensesnittet (GUI) noe særlig nyttig i R.\nMan kan kjøre R i et GUI som følger med R når man laster programmet, som heter R hva enn versjonsnummeret er, f.eks. R 4.2.2. Men det er bedre å bruke Rstudio til å arbeide med R i. Her får du et bra GUI som blant annet fullfører kodeforslag og har mange andre støttende funksjoner.\nVi arbeider vanligvis i skript, som har forkortelsen .R. Dette er likt SPSS’ syntaksfiler (.sps). Du kan kjøre hele skriptet, eller kun deler av skriptet av gangen. Kjør deler av skriptet ved å enten ha markøren i den linja eller marker flere linjer og trykk ctrl + enter.\nTil motsetning fra SPSS er Rs kodespråk lettere å lese og forstå (personlig mening). Man vil så klart aldri huske alle koder i R, men etter hvert vil en del av dem sitte fordi man bruker dem så ofte. Typiske eksempler på dette er %>%, filter() og mutate()."
  },
  {
    "objectID": "omR.html#excel",
    "href": "omR.html#excel",
    "title": "2  Om R",
    "section": "2.2 Excel",
    "text": "2.2 Excel\nDet er større forskjell på R og Excel. Excel er bygd rundt det grafiske grensesnittet. Det du ser er det du får (WYSIWYG). Dette har sine fordeler og bakdeler. Den største bakdelen, slik jeg ser det, er at Excel lar deg gjøre dumme ting. F.eks. hoppe over rader, forflytte en kolonne uten å mene det, glemme å markere alle felter, og det verste av alt: slå sammen celler.\nLikevel, det er mange ganger det er bedre å bruke Excel.\nVi kan importere excel-filer til R, hvilket er veldig nyttig. Den største utfordringa med dette er at vi må kjempe mot de bakdelene jeg nevnte over. Se mer om dette i Chapter 5.\nI motsetning til både Excel og SPSS så lagrer R dataene bare i internt minne mens du arbeider med dem. Dvs. at du ikke er avhengig av å mellomlagre alt som en .sav, .xlsx., eller .csv-fil. Dette kan bidra til å redusere behovet for mange versjoner av samme fil på ulike tidspunkter."
  },
  {
    "objectID": "omR.html#hvorfor-skal-jeg-bruke-r",
    "href": "omR.html#hvorfor-skal-jeg-bruke-r",
    "title": "2  Om R",
    "section": "2.3 Hvorfor skal jeg bruke R?",
    "text": "2.3 Hvorfor skal jeg bruke R?\nEn typisk tilbakemelding:\n\nDet tar tid å lære, det er en bratt læringskurve, og jeg får feilmeldinger hele tida.\n\nDet er noen fordeler med R som er attraktive for oss:\n\nNår du har laga et skript kan du, uten særlig mange endringer, kjøre skriptet på nytt gang etter gang. Dette sparer deg for mye tid istedenfor å måtte starte på nytt hver gang.\n\nDette er delvis mulig i SPSS-syntaks alt. R oppfordrer i større grad til dette via funksjonene sine, og måten den håndterer data på.\n\nMan kan bruke R til alt. Fra før av kan vi spleise data i SPSS, lage tabeller i Excel, gjøre dem interaktive i Infogram, dele dem via Google sheets, etc. R kan gjøre alt dette i samme programvare/GUI.\nR lese og skrive til de fleste vanlige programmer. Dvs. at vi kan starte en prosess i Excel og så fortsette den i R. Eller vi kan importere en Stata-fil til R, gjøre noen pivots og lagre den som en SPSS-fil. Dermed kan R relativt sømløst puttes inn i arbeidsprosessen. (Enklest blir det så klart å gjøre alt i R.)"
  },
  {
    "objectID": "omR.html#sec-versjering",
    "href": "omR.html#sec-versjering",
    "title": "2  Om R",
    "section": "2.4 Versjonering",
    "text": "2.4 Versjonering\nR, Rstudio, og alle pakkene til R kommer i ulike versjoner, f.eks. R v.4.2.2, Rstudio 2023.03.0, etc. Når man installerer en pakke vil den nyeste versjonen som er kompatibel med din versjon av R installeres. Her er noen ting å være oppmerksom på:\n\nNoen nye pakker funker ikke på gamle versjoner av R.\nNoen gamle pakker funker ikke eller litt annerledes på nye versjoner av R.\nNår pakker oppdateres vil noen ganger funksjonene deres endres.\n\nDette er en av bakdelene i tidyverse. De har endra på syntaksen sin slik at tidyverse-syntaks fra 2018 ikke gjelder i 2023. F.eks. pleide man å bruke mutate_at() før i tida for å mutere kun visse rader. Nå bruker man derimot en kombinasjon av mutate() og across() for å oppnå det samme. Dette er irriterende hvis du var vant til den gamle metoden.\n\nDu har alltid tilgang til eldre versjoner av R og Rs pakker. Dette er et viktig kjennetegn ved FOSS (free, open-source software). Hvis du trenger en funksjon fra en gammel versjon av en pakke, kan du alltids nedgradere R-versjonen og laste inn den versjonen av pakka. Jeg nevner det her, men det er mer for viderekommende, og for Linux-fantaster.\n\nPer nå er siste versjon vi har tilgang til på byplankontoret 4.2.3. Hvilken versjon har jeg?\n\nsessionInfo()\n\nR version 4.2.3 (2023-03-15 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 10 x64 (build 19045)\n\nMatrix products: default\n\nlocale:\n[1] LC_COLLATE=nb-NO.UTF-8  LC_CTYPE=nb-NO.UTF-8    LC_MONETARY=nb-NO.UTF-8\n[4] LC_NUMERIC=C            LC_TIME=nb-NO.UTF-8    \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.5.4 compiler_4.2.3    magrittr_2.0.3    fastmap_1.1.0    \n [5] cli_3.4.1         tools_4.2.3       htmltools_0.5.4   rstudioapi_0.14  \n [9] stringi_1.7.8     rmarkdown_2.17    knitr_1.40        stringr_1.4.1    \n[13] xfun_0.34         digest_0.6.30     jsonlite_1.8.3    rlang_1.0.6      \n[17] evaluate_0.17    \n\n\nJeg har forrige versjon, 4.2.21. Grunnen er at IT installerte den nye R-versjonen i dag, og jeg ikke vil ta sjansen på at det er små endringer i koden som ødelegger noe jeg har gjort før. Mest sannsynlig vil det går bra. Små endringer, som å gå fra x.x.2 til x.x.3 vil nok ikke ha noen merkbare endringer.\nTilstedeværelsen av alle disse ulike versjonene av pakker og programvare kan kanskje oppleves som plagsomt. Men det er faktisk en fordel, og en styrke ved R. Det medfører at vi kan garantere at et skript er future proof, at det alltids kan kjøre gitt samme data og datamaskin. Se mer om dette hos Brodrigues. Vi har for eksempel ingen garanti for at Excel i 2030 lar oss åpne og behandle filene våre fra 2020. Eller at alle funksjonene vi har i cellene forstås likt i begge versjonene av Excel. Dette er ikke overdrivelse. Da Excel gikk over fra .xls til .xlsx medførte det at nye versjoner av Excel ikke alltid greide å åpna de gamle filformatene. I denne situasjonen er du avhengig av at du får tilgang på en eldre versjon av programvaren for å åpna fila di. Det er ikke sikkert man får."
  },
  {
    "objectID": "pakker.html#tidyverse",
    "href": "pakker.html#tidyverse",
    "title": "3  Pakker",
    "section": "3.1 Tidyverse",
    "text": "3.1 Tidyverse\nTidyverse refererer til\n\nen designfilosofi\nen stor gruppe med pakker\nen spesifikk pakke som grupperer et lite antall pakker\n\nDu kan lese mer om Tidyverse på nettsida deres. Det er også en lærebok som går grundigere gjennom alle funksjonene deres, R for Data Science.\n\n\n\nTidyverse. Fra http://www.seec.uct.ac.za/r-tidyverse\n\n\nNår man kjører library(tidyverse) vil den laste inn alle pakkene nevnt her. Blant annet dplyr, ggplot2, etc. I tillegg laster den inn enkeltfunksjoner fra andre pakker. F.eks. laster den inn pipe operatoren ( %>%) fra magrittr. Mer om den seinere. Dermed er dette egentlig en snarvei for å slippe å laste inn flere pakker.\nTidyverse-pakkene er designa for å harmonisere med hverandre, og det gjør dem veldig sterke. Den underliggende filosofien gir også et bra rammeverk for andre pakker. Vinn-vinn.\nReint praktisk er det sånn at mange av funksjonene i tidyverse allerede eksisterer i base R. F.eks. filtrering, mutering, og etter R v.4.1., pipe-funksjonen. Jeg bruker likevel tidyverse-variantene fordi disse er så mye lettere å forstå, skrive, og lese. De er utvikla for folk som jobber som oss, med tabeller og datasett. Som nybegynner er det ikke bare bare å forstå forskjellen mellom base R og tidyverse, så her er det viktigste:\n\nNår dere søker opp løsninger vil det ofte presenteres løsninger både i base R og i tidyverse. Dette skjer ofte på StackOverflow.\nDe fleste tidyverse-funksjoner har et datasett som første argument i funksjonen. Dette gjør at vi lett kan pipe funksjoner etter hverandre."
  },
  {
    "objectID": "pakker.html#piper",
    "href": "pakker.html#piper",
    "title": "3  Pakker",
    "section": "3.2 Piper",
    "text": "3.2 Piper\nHvorfor er piper så nyttig? De lar oss flette sammen en serie operasjoner uten å måtte mellomlagre objekter. La oss si at vi har et datasett med biler og deres egenskaper. Vi vil\n\nfiltrere ut dem som har under seks sylindre\ngjøre om vekta fra lbs. til kg.\ngruppere etter antall gir\nvise snitt av miles/gallon (mpg).\n\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.3.6      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\n\n\n3.2.1 Uten pipa\n\nmtcars <- mtcars\ncars_filtered <- filter(mtcars, cyl >= 6)\ncars_filtered_kg <- mutate(cars_filtered, wt = wt * 0.45359237)\ncars_filtered_kg_grouped <- group_by(cars_filtered_kg, gear)\ncars_filtered_kg_grouped_mean <- summarise(cars_filtered_kg_grouped, snitt = mean(mpg))\n\ncars_filtered_kg_grouped_mean\n\n# A tibble: 3 × 2\n   gear snitt\n  <dbl> <dbl>\n1     3  15.7\n2     4  19.8\n3     5  16.8\n\n\n\n\n3.2.2 Med pipa\n\ncars_filtered_kg_group_mean <- mtcars %>% \n  filter(cyl >= 6) %>% \n  mutate(wt = wt * 0.45359237) %>% \n  group_by(gear) %>% \n  summarise(snitt = mean(mpg))\n\ncars_filtered_kg_grouped_mean\n\n# A tibble: 3 × 2\n   gear snitt\n  <dbl> <dbl>\n1     3  15.7\n2     4  19.8\n3     5  16.8\n\n\nDet andre eksemplet er\n\nmer lesbart\nmindre stappfult av midlertidige objekter som vi seinere må slette eller som uansett overskriver hverandre.\n\nJeg kommer til å bruke piper en god del både her og i alle skriptene mine. Så det er greit å vite hva det går ut på. Syntaksen x %>% y kan leses som y får x. Vi tar x og sender det til y som tar det inn som sitt første argument. Tidyverse-funksjonene er bygd rundt ideen om at det første argumentet til funksjonene er et datasett. Legg merke til at det er et datasett som er det første objektet i alle funksjonen jeg bruker i eksemplet uten pipe.\nNoen funksjoner, som base::sum() har ikke data som sitt første argument, men en vektor. Hvis man sender et datasett til sum() vil man få en feilmelding.\n\nmtcars %>% sum(wt)\n\nError in mtcars %>% sum(wt): object 'wt' not found\n\n\nFor å få slike funksjoner til å funkere med ei pipe, kan man ofte bruke en funksjon fra magrittr:\n\nmtcars %>% sum(.$wt)\n\n[1] 14045.15\n\n\n. blir her et alias for det aktuelle datasett, og dette er det samme som å skrive:\n\nsum(mtcars$wt)\n\n[1] 102.952\n\n\nDa jeg lærte R var det %>% fra magrittr som var den gjeldende pipa. Den var så nyttig at ei pipe til slutt blei inkorporert i base R. Dette skjedde i R 4.1.0. Base Rs pipe ser slik ut: |>. Den fungerer i hovedsak lik %>%. Når jeg fortsetter å bruke den gamle magrittr-pipa er det bare fordi jeg er gammel og ikke liker å endre på ting som funker. Dessuten har Rstudio en flott snarvei til %>% via ctrl + shift + M.\nDere velger altså sjøl om dere går for %>% eller |>. Husk bare at for å bruke %>% så må tidyverse eller magrittr lastes inn først. (tidyverse låner noen av funksjonene fra magrittr, men laster ikke inn alle funksjonene fra den pakka).\n\n\n3.2.3 Hva er pipa ikke?\nEn vanlig intuisjon man får når man begynner med piper er at det er en måte å “arbeide baklengs”. Man starter å lese nedenfra og opp. Dette stemmer ikke. Tenk heller at du starter med en ting, sender den videre til en funksjon, og sender resultatet av dette videre til neste funksjon, sender resultatet av dette videre til neste funksjon, og så videre."
  },
  {
    "objectID": "grunnleggende.html",
    "href": "grunnleggende.html",
    "title": "4  Det grunnleggende",
    "section": "",
    "text": "5 Data frame\nVi arbeider mest med datasett, og disse har en egen klasse i R, nemlig data frame. Jeg kommer ikke på noen god norsk oversettelse av data frame, så jeg bruker det engelske ordet. Dette fordi jeg på engelsk ville skilt mellom datasets, altså et datasett som kunne finnes i ulike dataformater (.sav, .csv, .xlsx) og data frames, altså en datastruktur i R.\nDet interessante med data frames er at de faktisk bare er lister. Det vil si at mye av det vi veit om lister kan brukes på data frames. Et data frame er strengt tatt bare ei liste med vektorer. Hver vektor blir en kolonne i data framen. Hva representerer hver rad? Det er ikke gitt, men vi kan vanligvis tenke på hver rad som en observasjon. Når vi prater om tidy data vil dette bli utdypa.\nDet er noen begrensninger eller krav ved datasett: hver kolonne må ha lik lengde. Hvis ikke får du feilmelding.\nR er snill og gir oss tydelig beskjed om hva som er galt i feilmeldinga.\nEn ting som er fint med alle disse R-pakkene, er at de ofte inkluderer datasett som vi kan bruke for å illustrere pakkens funksjoner. Disse datasetta ligger tilgjengelig på samme måte som funksjonene: man bare skriver navnet dens for å påkalle den. La oss hente et datasett som kommer fra dplyr (som er en del av tidyverse).\nDet kan føles rart å jobbe med data som vi ikke veit hvor ligger. Så jeg kan plassere det explisitt i miljøet vårt (environment), ved å assigne det.\nLa oss bruke dette datasettet for å vise noen flere egenskaper ved R. Men vent, er dette et data frame?"
  },
  {
    "objectID": "grunnleggende.html#sec-rstudio",
    "href": "grunnleggende.html#sec-rstudio",
    "title": "4  Det grunnleggende",
    "section": "4.1 Rstudio",
    "text": "4.1 Rstudio\nMen først av alt bør vi ta en titt på Rstudio. Dette er som nevnt det grafiske brukergrensesnittet som vi arbeider i når vi jobber med R. Et typisk Rstudio-vindu kan se slik ut:\n\n\n\nRstudio in action, med tema Tomorrow Night 80s\n\n\nHvis du har kjedeligere farger er det nok fordi du ikke har oppdaga de flotte temaene som du kan velge mellom i Rstudio. Kikk på Tools/Global options/Appearance og endre Editor theme til noe som faller deg i smak. Min favoritt for tida er Tomorrow Night 80s. Grensesnittet består av fire ruter (panes), som hver kan ha flere faner (tabs).\nNår du først er i innstillinger: Skru av Restore .RData into workspace on startup og velg never på Save workspace to .RData on exit. Dette er innstillinger som gjør det litt raskere for deg å komme inn i et prosjekt, men som vil gi deg en falsk trygghet, og som inviterer til noen av de feilene om jeg omtaler i Chapter 12. Derfor skrur vi dem av.1\n\n\n\nSlik skal det se ut\n\n\n\n4.1.1 Rute 1: Kilde (source)\nI denne ruta havner alle skriptene våre. Vi skriver alle kommandoene våre i skript som vi deretter kjører. Dette er likt hvordan syntaks/skript kan brukes i Stata og SPSS. Disse skripta blir en oppskrift for oss seinere som forteller oss hva som blei gjort. Du kan kjøre ei og ei linje ved å trykke ctrl + enter2, eller du kan markere det du vil kjøre og trykke det samme. Du kan kjøre hele skriptet ved å trykke ctrl + alt + enter. Skript lar deg enkelt dele arbeidet ditt med andre. Du bør være flink på å dokumentere det du gjør ved å bruke kommentarer. Dette er linjer som starter med #. Disse linjene vil ignoreres av R når du kjører skriptet.\nDu kan se at jeg har skrevet noe kode i skriptet mitt. Jeg lager en vektor som heter noen_tall og et datasett som heter et_datasett.\n\n\n4.1.2 Rute 2: Konsollen (console)\nMan kan også skrive kommandoer rett til konsollen. Da blir de kjørt med en gang man trykker enter. De kodene du skriver til konsollen vil ikke bli lagra noe sted, så hvis du jobber mye her vil du ikke dokumentere arbeidet ditt. Så ikke gjør det til en vane å bruke konsollen mye. Den er nyttig hvis du veit at du ikke trenger å ta vare på akkurat det du gjør nå. F.eks. hvis du skal regne ut noe fort, eller printe et objekt for å inspisere det.\nNår du kjører skript vil koden skrives ut til konsollen. Du kan se at jeg har kjørt kodene i skriptet fordi de er blitt skrevet til konsollen.\n\n\n4.1.3 Rute 3: Miljøet (environment) med mer\nDe to siste rutene kan inneholde diverse faner, avhengig av hva du krysser av for i Pane layout i global options. Vanligvis viser det oss miljøet vårt. Her finner du en oversikt over alle objektene du har laga hittil i sesjonen (session) din. En sesjon starter når du starter R (som starter når du starter Rstudio). Den varer til du skrur av R eller restarter den manuelt. Du restarter den manuelt ved å gå til Session/Restart R eller trykke ctrl + shift + F10.\nDu kan se at det ligger en vektor, et datasett og en funksjon (stilim()) i mijøet mitt. De to første er det jeg lagde i skriptet. Da koden blei kjørt lagde de to objekter (et datasett og en vektor), og alle objekter legges i miljøet. Funksjonen ligger der fordi den er definert i min .Rprofile. Dette går jeg ikke inn på her, for det er et mer avansert tema. Det holder å si at denne funksjonen blir lasta inn i miljøet mitt hver gang jeg starter en R-sesjon.\nDet er andre faner i denne ruta som kan være nyttig, men vi trenger ikke bry oss om dem nå. Kort fortalt viser History oss hvilke koder vi nettopp har kjørt, og Git kan brukes hvis vi bruker Git som et version control system.\n\n\n4.1.4 Rute 4: Filer, plott, visning, hjelp med mer\nHer ligger det flere faner som er interessant for oss.\n\n4.1.4.1 Files\nVanligvis ser vi filene i den mappa vi befinner oss her, hvis fana Files er valgt. Her ligger alle filene jeg har i min mappe for øyeblikket. Det er noe rotete. Herfra kan du enkelt åpne andre skript.\n\n\n4.1.4.2 Plots\nHvis du lager en figur eller graf vil plottet kunne vises her.\n\n\n4.1.4.3 Help\nLær å like Help. Her kan du søke opp funksjoner for å få hjelp til å bruke dem. Du kan enten bruke søkefeltet i høyre hjørne av fana, eller kjøre denne koden ?funksjonsnavn. F.eks.\n\n?mutate\n\nDa vil hjelpevinduet dukke opp.\n\n\n4.1.4.4 Viewer\nViewer lar oss forhåndsvise f.eks. html-sider, Shiny-apps og andre dokumenter vi produserer."
  },
  {
    "objectID": "grunnleggende.html#filer-vi-bruker-i-r",
    "href": "grunnleggende.html#filer-vi-bruker-i-r",
    "title": "4  Det grunnleggende",
    "section": "4.2 Filer vi bruker i R",
    "text": "4.2 Filer vi bruker i R\n\n4.2.1 .R\nDen viktigste filtypen å vite om er R-skript. Disse filene ender i .R. Når du arbeider, arbeider du hovedsaklig i .R. Du skriver koder, og kan kjøre hele eller deler av skriptet. Du kan legge inn kommentarer ved bruk av #. Hold skripta dine ryddig og du vil takke deg sjøl seinere.\n\n\n4.2.2 .rmd\nNoen ganger vil du skrive mye, og legge inn koder her og der. F.eks. hvis du vil lage en lærebok, unnskyld, en lærepamflett, i R. Siden du skal skrive så mye er det strevsomt å skulle legge inn kommentarer overalt. Da bruker vi istedenfor et Rmarkdown-dokument. Disse har forkortelsen .Rmd3. Rmarkdown er en avvart av vanlig markdown-dokumenter. Markdown er en genial oppfinnelse, som lar deg skrive enkle dokumenter med enkle formateringer kjapt. Her er en grei intro til markdown. Rmarkdown baserer seg på de samme prinsippene, men har noe utvida funksjonalitet til å fungere med R og Rstudio. Når du vil kjøre kode lager du en kodeblokk, og skriver koden inn der. Dette lar deg kombinere tekst, kode, figurer og tabeller på en kraftig måte. Du slipper den evige dansen mellom et statistikkprogram, klipp og lim, og Word. Alt skrives samtidig, og du strikker sammen dokumentet med pakka knitr. Outputen blir enten en .html-fil som kan leses i nettleseren eller en .pdf-fil.\n\n\n4.2.3 .qmd\nSelskapet formerly known as Rstudio, Posit, gjorde nylig en rebranding fra å fokusere på hovedsaklig R til å fokusere på flere programmeringsspråk. I den anledning lagde de en “ny versjon” av Rmarkdown som var mer kompatibel med disse språka. Resultatet blei en “oppdatert” versjon av rmarkdown som heter quarto. Alt jeg har sagt om Rmarkdown gjelder for quarto også. Ærlig talt er det ikke så lett å få tak i hva som er annerledes med de to. I arbeidet med denne pamfletten begynte jeg å bruke quarto istedenfor rmarkdown. Her er en intro til quarto.\n{width = 70%} ### .Rporj\nDette er et R-prosjekt. Du bør organisere arbeidet ditt i prosjekter. Vi prater mer om dette i (arbeidsprosess?)."
  },
  {
    "objectID": "grunnleggende.html#vektor",
    "href": "grunnleggende.html#vektor",
    "title": "4  Det grunnleggende",
    "section": "4.3 Vektor",
    "text": "4.3 Vektor\nDet grunnleggende elementet i R er en vektor. En vektor kan forstås som en liste av elementer med samme type. Vi kan ha vektorer av tall, bokstaver, faktorer. De tre siste er eksempler på klasser. Det er noen forskjellige klasser, men vi bryr oss mest om disse tre.\nLa oss lage en vektor\n\nc(1, 2, 3)\n\n[1] 1 2 3\n\n\nFunksjonen c() kombinerer verdier til en vektor.\nNår vi skriver en kommando vil R alltid returnere noe til oss. Det blir vanligvis printa til skjermen. Hvis vi heller vi lagre det som et objekt som vi kan henvise til seinere, bruker vi assignment for å gi verdien(e) til et objekt vi navngir.\nSlik:\n\nvektor1 <- c(1, 2, 3)\nvektor1\n\n[1] 1 2 3\n\n\n\n\n\n\n\n\nNote\n\n\n\nNår man gir en verdi bruker man en av to operatorer: enten <- eller =. Det er generelt ansett at man bør bruke pila istedenfor likhetstegn. Årsakene er\n\n= (assignment) er lett å forveksle med == (comparison). Det er enklere å unngå dette med pila\npila er anvendelig. Du kan faktisk skrive den motsatt vei, slik: c(1, 2, 3) -> vektor1. Når det er sagt, lov meg at du aldri gjør dette med mindre du har en utrolig god grunn. Enkelte konvensjoner er smart å beholde.\n\nDerfor bruker jeg alltid <-, og anbefaler deg det også.\n\n\nTall kan man, som vi ser, bare skrive rett ut. Bokstaver, derimot, må deklareres som en streng. Dette gjøres ved å omkranse dem i hermetegn:\n\nvektor2 <- c(\"A\", \"B\", \"C\")\nvektor2\n\n[1] \"A\" \"B\" \"C\"\n\n\nEn vektor som består av bokstaver eller ord kalles en character vector eller en string.\nVi kommer oss langt med numeriske vektorer og strengvektorer. Her er det verdt å merke at det er forskjellige varianter av numeriske vektorer: De kan være Int, double, eller float. Forskjellen er sjelden viktig for oss, så jeg går ikke inn på det.\nMer inngående info om vektorer og klasser kan finnes her.\nEn vektor kan bestå av alt fra ett til mange elementer. Men den kan bare bestå av elementer av samme klasse\nLa oss se kjapt på andre typer dataverdier vi kan arbeide med.\n\n4.3.1 Datoer\nDatoer er spesielle verdier i R. Dette lar oss gjøre spesielle ting som å regne ut tidsdifferansen mellom to datoer i dager, måneder eller år, og mange andre nyttige ting. Pakka lubridate inneholder mange nyttige funksjoner som utvider de som ligger i base R. Er lubridate en del av tidyverse? Så klart.\n\n\n4.3.2 Logiske verdier\nDet er også verdt å være oppmerksom på logiske vektorer. Elementer i disse vektorene kan kun være enten TRUE (sann) eller FALSE (usann). De brukes mye i filtrering og testing.\n\n\n4.3.3 Missing (NA)\nDet siste typen element vi må huske på er missing. Alle dataprogrammer har ulik måte å lagre såkalte missing data på. I R vises de som NA. Det er masse vi kunne sagt om NA, mer enn jeg rekker her. Jeg nevner kjapt: En del funksjoner, spesielt i base R liker ikke missing. Blant annet sum(). Den vil gi NA som svar dersom det er missing tilstede i datasettet, hvilket aldri er det vi forventer oss. Disse funksjonene har alltid mulighet til å ignorere missing ved å sette et spesielt argument. F.eks. na.rm = TRUE\n\n# En tilfeldig vektor med missing\nfoo <- c(1, 2, 3, NA)\n\n# Forventer 6, får NA.\nsum(foo)\n\n[1] NA\n\n# Slik ber vi sum ignorere missing.\nsum(foo, na.rm = TRUE)\n\n[1] 6\n\n\nNår vi importerer filer fra andre programmer hender det vi får med oss deres definisjon av missing. F.eks. er missing noen ganger koda som -999 i SPSS-filer. Her kan det skje feil slik at disse verdiene blir til 999 i R. Det skjer sjelden, men det er verdt å være oppmerksom på muligheten for at det skjer.\n\n\n4.3.4 Faktor\nFaktorer (factors) må også nevnes. Disse er nyttige for grupperinger, og noen funksjoner kan merke seg hvilke variabler som er faktorer og utføre heuristikker basert på det. Sjøl syns jeg faktorer er knotete å forholde seg til, så jeg foretrekker å bare bruke strengvektorer."
  },
  {
    "objectID": "grunnleggende.html#liste",
    "href": "grunnleggende.html#liste",
    "title": "4  Det grunnleggende",
    "section": "4.4 Liste",
    "text": "4.4 Liste\nEn liste er som en vektor på steroider. Den kan består av elementer av ulik klasse. I tillegg kan en liste bestå av andre lister. Det gjør dem kraftig, og anvendbar.\n\n# En liste bestående av fem tall. Dette kunne like gjerne vært en vektor\nliste1 <- list(1, 2, 3, 4, 5)\nliste1\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n[[4]]\n[1] 4\n\n[[5]]\n[1] 5\n\n# Denne lista har elementer av ulik klasse.\nliste1 <- list(1, \"B\", 3, \"D\", 5)\nliste1\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"B\"\n\n[[3]]\n[1] 3\n\n[[4]]\n[1] \"D\"\n\n[[5]]\n[1] 5\n\n# En liste bestående av flere vektorer og lister. \nliste2 <- list(\n  vektorA = c(1, 2, 3, 4),\n  vektorB = c(\"ET\", \"IJ\", \"SW\"), \n  liste1 = list(3, 4, 5)\n)\nliste2\n\n$vektorA\n[1] 1 2 3 4\n\n$vektorB\n[1] \"ET\" \"IJ\" \"SW\"\n\n$liste1\n$liste1[[1]]\n[1] 3\n\n$liste1[[2]]\n[1] 4\n\n$liste1[[3]]\n[1] 5\n\n\nVi får direkte tilgang på elementene av objekter ved å bruke firkantklammer ([], a.k.a. hakeparentes, square brackets, box brackets). Da bruker vi indeksen til elementet for å henvise til det. Indeksen er rekkefølga til elementet. R er 1-indeksert. Det vil si at indeksen starter på 1. Andre programmeringsspråk, slik som Python, starter på 0. Seinere skal vi se at det går an å henvise til elementer ut fra navna deres, men det tar vi når vi kommer til det.\n\n# Hva er det første elementet i vektor1?\nvektor1[1]\n\n[1] 1\n\n# Hva er det andre elementet i liste2?\nliste2[2]\n\n$vektorB\n[1] \"ET\" \"IJ\" \"SW\"\n\n\nSpesielt når vi holder på med lister er det verdt å vite om dobbel firkantklammer ([[]]). Vanlige firkantklammer gir deg ei liste med element(ene) på denne indeksen. Doble firkantklammer gir deg sjølve element(ene) på denne indeksen. Du kan se forskjellen her:\n\n# Sjølve det som blir returnert.\nliste2[2] \n\n$vektorB\n[1] \"ET\" \"IJ\" \"SW\"\n\nliste2[[2]]\n\n[1] \"ET\" \"IJ\" \"SW\"\n\n# Det blir tydeligere om vi undersøker klassen til objektene som blir returnert\nliste2[2] %>% class() # liste\n\n[1] \"list\"\n\nliste2[[2]] %>% class() # character (alstå en tekstvektor)\n\n[1] \"character\"\n\n\nVi bruker ikke så ofte lister direkte, men de er viktige av årsaker som straks blir klart. Det siste jeg vil påpeke om lister er at de er rekursive, det vil si at du kan ha ei liste som et element av ei liste. Dermed følger det at vi kan ha ei liste som er et element av ei liste som er et element av ei liste som …\n\n\n\nOg så videre"
  },
  {
    "objectID": "grunnleggende.html#tilbake-til-elementer",
    "href": "grunnleggende.html#tilbake-til-elementer",
    "title": "4  Det grunnleggende",
    "section": "5.1 Tilbake til elementer",
    "text": "5.1 Tilbake til elementer\nNå som vi har tilgang til et større datasett kan vi utforske litt mer hvordan vi arbeider med, nettopp, større datasett. Datasettet starwars inneholder informasjon om dokumentarserien Star Wars, som omhandla livet i gamle dager, i en galakse langt, langt vekk.\n\nstarwars\n\n# A tibble: 87 × 14\n   name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵\n   <chr>        <int> <dbl> <chr>   <chr>   <chr>     <dbl> <chr> <chr>  <chr>  \n 1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…\n 2 C-3PO          167    75 <NA>    gold    yellow    112   none  mascu… Tatooi…\n 3 R2-D2           96    32 <NA>    white,… red        33   none  mascu… Naboo  \n 4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…\n 5 Leia Organa    150    49 brown   light   brown      19   fema… femin… Aldera…\n 6 Owen Lars      178   120 brown,… light   blue       52   male  mascu… Tatooi…\n 7 Beru White…    165    75 brown   light   blue       47   fema… femin… Tatooi…\n 8 R5-D4           97    32 <NA>    white,… red        NA   none  mascu… Tatooi…\n 9 Biggs Dark…    183    84 black   light   brown      24   male  mascu… Tatooi…\n10 Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon\n# … with 77 more rows, 4 more variables: species <chr>, films <list>,\n#   vehicles <list>, starships <list>, and abbreviated variable names\n#   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld\n\n\nPå tide å utforske. Vi kan henvise til spesifikke celler via x- og y-koordinater.\n\n# Vi kan finne en nøyaktig celle ved å henvise til x- og y-koordinatene\nstarwars[2, 1]\n\n# A tibble: 1 × 1\n  name \n  <chr>\n1 C-3PO\n\nstarwars[5, 4]\n\n# A tibble: 1 × 1\n  hair_color\n  <chr>     \n1 brown     \n\n# Vi kan få tak i en serie med elementer via `:`\nstarwars[1:3]\n\n# A tibble: 87 × 3\n   name               height  mass\n   <chr>               <int> <dbl>\n 1 Luke Skywalker        172    77\n 2 C-3PO                 167    75\n 3 R2-D2                  96    32\n 4 Darth Vader           202   136\n 5 Leia Organa           150    49\n 6 Owen Lars             178   120\n 7 Beru Whitesun lars    165    75\n 8 R5-D4                  97    32\n 9 Biggs Darklighter     183    84\n10 Obi-Wan Kenobi        182    77\n# … with 77 more rows\n\n# Vi kan gjøre et utvalg av celler ved å definere både x og y som en serie\nstarwars[2:5, 6:9]\n\n# A tibble: 4 × 4\n  eye_color birth_year sex    gender   \n  <chr>          <dbl> <chr>  <chr>    \n1 yellow         112   none   masculine\n2 red             33   none   masculine\n3 yellow          41.9 male   masculine\n4 brown           19   female feminine \n\n\nDet er upraktisk å skulle huske indekser til alt. Heldigvis kan vi henvise til kolonner dersom de er navngitt, slik som her:\n\nstarwars[\"eye_color\"]\n\n# A tibble: 87 × 1\n   eye_color\n   <chr>    \n 1 blue     \n 2 yellow   \n 3 red      \n 4 yellow   \n 5 brown    \n 6 blue     \n 7 blue     \n 8 red      \n 9 brown    \n10 blue-gray\n# … with 77 more rows\n\n# En nyttig funksjon for å finne navna til alle kolonnene (variablene) er:\ncolnames(starwars)\n\n [1] \"name\"       \"height\"     \"mass\"       \"hair_color\" \"skin_color\"\n [6] \"eye_color\"  \"birth_year\" \"sex\"        \"gender\"     \"homeworld\" \n[11] \"species\"    \"films\"      \"vehicles\"   \"starships\" \n\nstarwars[\"species\"]\n\n# A tibble: 87 × 1\n   species\n   <chr>  \n 1 Human  \n 2 Droid  \n 3 Droid  \n 4 Human  \n 5 Human  \n 6 Human  \n 7 Human  \n 8 Droid  \n 9 Human  \n10 Human  \n# … with 77 more rows\n\n\nEt alterntiv til klammeparantesen er å bruke operatoren `$´.\n\n# Her trenger man ikke hermetegn, med mindre kolonna har mellomrom.\nstarwars$name\n\n [1] \"Luke Skywalker\"        \"C-3PO\"                 \"R2-D2\"                \n [4] \"Darth Vader\"           \"Leia Organa\"           \"Owen Lars\"            \n [7] \"Beru Whitesun lars\"    \"R5-D4\"                 \"Biggs Darklighter\"    \n[10] \"Obi-Wan Kenobi\"        \"Anakin Skywalker\"      \"Wilhuff Tarkin\"       \n[13] \"Chewbacca\"             \"Han Solo\"              \"Greedo\"               \n[16] \"Jabba Desilijic Tiure\" \"Wedge Antilles\"        \"Jek Tono Porkins\"     \n[19] \"Yoda\"                  \"Palpatine\"             \"Boba Fett\"            \n[22] \"IG-88\"                 \"Bossk\"                 \"Lando Calrissian\"     \n[25] \"Lobot\"                 \"Ackbar\"                \"Mon Mothma\"           \n[28] \"Arvel Crynyd\"          \"Wicket Systri Warrick\" \"Nien Nunb\"            \n[31] \"Qui-Gon Jinn\"          \"Nute Gunray\"           \"Finis Valorum\"        \n[34] \"Jar Jar Binks\"         \"Roos Tarpals\"          \"Rugor Nass\"           \n[37] \"Ric Olié\"              \"Watto\"                 \"Sebulba\"              \n[40] \"Quarsh Panaka\"         \"Shmi Skywalker\"        \"Darth Maul\"           \n[43] \"Bib Fortuna\"           \"Ayla Secura\"           \"Dud Bolt\"             \n[46] \"Gasgano\"               \"Ben Quadinaros\"        \"Mace Windu\"           \n[49] \"Ki-Adi-Mundi\"          \"Kit Fisto\"             \"Eeth Koth\"            \n[52] \"Adi Gallia\"            \"Saesee Tiin\"           \"Yarael Poof\"          \n[55] \"Plo Koon\"              \"Mas Amedda\"            \"Gregar Typho\"         \n[58] \"Cordé\"                 \"Cliegg Lars\"           \"Poggle the Lesser\"    \n[61] \"Luminara Unduli\"       \"Barriss Offee\"         \"Dormé\"                \n[64] \"Dooku\"                 \"Bail Prestor Organa\"   \"Jango Fett\"           \n[67] \"Zam Wesell\"            \"Dexter Jettster\"       \"Lama Su\"              \n[70] \"Taun We\"               \"Jocasta Nu\"            \"Ratts Tyerell\"        \n[73] \"R4-P17\"                \"Wat Tambor\"            \"San Hill\"             \n[76] \"Shaak Ti\"              \"Grievous\"              \"Tarfful\"              \n[79] \"Raymus Antilles\"       \"Sly Moore\"             \"Tion Medon\"           \n[82] \"Finn\"                  \"Rey\"                   \"Poe Dameron\"          \n[85] \"BB8\"                   \"Captain Phasma\"        \"Padmé Amidala\"        \n\nstarwars$\"name\"\n\n [1] \"Luke Skywalker\"        \"C-3PO\"                 \"R2-D2\"                \n [4] \"Darth Vader\"           \"Leia Organa\"           \"Owen Lars\"            \n [7] \"Beru Whitesun lars\"    \"R5-D4\"                 \"Biggs Darklighter\"    \n[10] \"Obi-Wan Kenobi\"        \"Anakin Skywalker\"      \"Wilhuff Tarkin\"       \n[13] \"Chewbacca\"             \"Han Solo\"              \"Greedo\"               \n[16] \"Jabba Desilijic Tiure\" \"Wedge Antilles\"        \"Jek Tono Porkins\"     \n[19] \"Yoda\"                  \"Palpatine\"             \"Boba Fett\"            \n[22] \"IG-88\"                 \"Bossk\"                 \"Lando Calrissian\"     \n[25] \"Lobot\"                 \"Ackbar\"                \"Mon Mothma\"           \n[28] \"Arvel Crynyd\"          \"Wicket Systri Warrick\" \"Nien Nunb\"            \n[31] \"Qui-Gon Jinn\"          \"Nute Gunray\"           \"Finis Valorum\"        \n[34] \"Jar Jar Binks\"         \"Roos Tarpals\"          \"Rugor Nass\"           \n[37] \"Ric Olié\"              \"Watto\"                 \"Sebulba\"              \n[40] \"Quarsh Panaka\"         \"Shmi Skywalker\"        \"Darth Maul\"           \n[43] \"Bib Fortuna\"           \"Ayla Secura\"           \"Dud Bolt\"             \n[46] \"Gasgano\"               \"Ben Quadinaros\"        \"Mace Windu\"           \n[49] \"Ki-Adi-Mundi\"          \"Kit Fisto\"             \"Eeth Koth\"            \n[52] \"Adi Gallia\"            \"Saesee Tiin\"           \"Yarael Poof\"          \n[55] \"Plo Koon\"              \"Mas Amedda\"            \"Gregar Typho\"         \n[58] \"Cordé\"                 \"Cliegg Lars\"           \"Poggle the Lesser\"    \n[61] \"Luminara Unduli\"       \"Barriss Offee\"         \"Dormé\"                \n[64] \"Dooku\"                 \"Bail Prestor Organa\"   \"Jango Fett\"           \n[67] \"Zam Wesell\"            \"Dexter Jettster\"       \"Lama Su\"              \n[70] \"Taun We\"               \"Jocasta Nu\"            \"Ratts Tyerell\"        \n[73] \"R4-P17\"                \"Wat Tambor\"            \"San Hill\"             \n[76] \"Shaak Ti\"              \"Grievous\"              \"Tarfful\"              \n[79] \"Raymus Antilles\"       \"Sly Moore\"             \"Tion Medon\"           \n[82] \"Finn\"                  \"Rey\"                   \"Poe Dameron\"          \n[85] \"BB8\"                   \"Captain Phasma\"        \"Padmé Amidala\"        \n\n\nSom du begynner å skjønne er det flere veier til Rom. Klammeparantesen og $ har tildels overlappende funksjoner. De har likevel sine unike bruksområder. De vil vi lære å anerkjenne etter hvert som vi arbeider med dem. En nyttig ting med [] er at vi kan bruke det som et enkelt filter.\n\n# Velg kun de karakterene som er menneske\nstarwars[starwars$species == \"Human\", ]\n\n# A tibble: 39 × 14\n   name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵\n   <chr>        <int> <dbl> <chr>   <chr>   <chr>     <dbl> <chr> <chr>  <chr>  \n 1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…\n 2 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…\n 3 Leia Organa    150    49 brown   light   brown      19   fema… femin… Aldera…\n 4 Owen Lars      178   120 brown,… light   blue       52   male  mascu… Tatooi…\n 5 Beru White…    165    75 brown   light   blue       47   fema… femin… Tatooi…\n 6 Biggs Dark…    183    84 black   light   brown      24   male  mascu… Tatooi…\n 7 Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon\n 8 Anakin Sky…    188    84 blond   fair    blue       41.9 male  mascu… Tatooi…\n 9 Wilhuff Ta…    180    NA auburn… fair    blue       64   male  mascu… Eriadu \n10 Han Solo       180    80 brown   fair    brown      29   male  mascu… Corell…\n# … with 29 more rows, 4 more variables: species <chr>, films <list>,\n#   vehicles <list>, starships <list>, and abbreviated variable names\n#   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld\n\n\nDette er noe knotete: Du må gjengi datasettnavnet inni klamma, og du må huske på kommaet for å implisitt velge alle rader. Dessuten vil du bare få treff på nøyaktig det samme. Hvis noen har en species som er skrevet f.eks. human eller human/alien vil vi ikke få treff. Hvis det bare hadde fantes en smartere implementering av dette filteret …\nOg det gjør det! I, nettopp, tidyverse! \nPå tampen, noen nyttige digresjoner."
  },
  {
    "objectID": "grunnleggende.html#digresjoner",
    "href": "grunnleggende.html#digresjoner",
    "title": "4  Det grunnleggende",
    "section": "5.2 Digresjoner",
    "text": "5.2 Digresjoner\n\n5.2.1 Navngitte lister/vektorer\nVi returnerer til lister og vektorer. Tenk på de vi lagde tidligere:\n\nvektor1\n\n[1] 1 2 3\n\nliste1\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"B\"\n\n[[3]]\n[1] 3\n\n[[4]]\n[1] \"D\"\n\n[[5]]\n[1] 5\n\n\nDe er enkle. Kan vi gjøre dem … mer komplisert? Så klart. Noe som ofte vil være nyttig for oss er det å bruke navngitte vektorer eller lister (named vector/named list). Hva er det? Det er en vektor eller liste hvor hvert element har et navn. La oss se noen eksempler. (Jeg viser bare for vektorer, men det samme gjelder for lister.)\n\nnavngitt_vektor <- c(\"navn\" = \"Arnold\",\n                     \"hilsen\" = \"hey\",\n                     \"venn\" = \"Gerald\")\n\n# Nå har hvert element i vektoren et navn\nnavngitt_vektor\n\n    navn   hilsen     venn \n\"Arnold\"    \"hey\" \"Gerald\" \n\n# Sammenlikn med den tidligere, navnløse vektoren. \nvektor2\n\n[1] \"A\" \"B\" \"C\"\n\n# Vi kan også bruke funksjonen `setNames()` til å gi navn. Nyttig hvis vi har\n# navna lagra i en annen vektor/liste\nnavn <- c(\"Første\", \"Andre\", \"Tredje\")\n\nsetNames(vektor2, navn)\n\nFørste  Andre Tredje \n   \"A\"    \"B\"    \"C\" \n\n# Men --- hvor har navna våre blitt av??\nvektor2\n\n[1] \"A\" \"B\" \"C\"\n\n# Vi må huske å bruke *assignment* for å large det vi gjør\nvektor2 <- setNames(vektor2, navn)\nvektor2\n\nFørste  Andre Tredje \n   \"A\"    \"B\"    \"C\" \n\n\nHvorfor er det nyttig? Navngitte vektorer og lister er nyttig fordi det er mange funskjoner i spesielt tidyverse som nyttiggjør seg av dem. Når man for eksempel bruker rename() til å endre navn på variabler kan man sende en navngitt vektor for å endre mange navn på en gang. Dette gjør at vi mer programmatisk kan endre navn istedenfor å skrive hvert ledd. Når vi har mange ledd, slik som i navn på plansoner og kommunenummer, blir dette svært nyttig.\nForresten, her er en ting jeg ofte brenner meg på: Når du bruker setNames() kommer elementnavna etter elementene. Når du navngir elementene mens du lager vektoren/lista, kommer elemtnnavna først. Du ser det i eksemplene over.\n\n\n5.2.2 Assignment (= og <-)\nKanskje dere føler dere lurt av noe jeg så tidligere.\n\nDerfor bruker jeg alltid <-, og anbefaler deg det også.\n\nOg litt lengre ned viser\n\n# En enkel data frame.\ndat1 <- data.frame(\n  personer = c(\"Luke\", \"Han\", \"Darth\"),\n  moral = c(\"Bra\", \"Nja\", \"Dårlig\")\n)\ndat1\n\n  personer  moral\n1     Luke    Bra\n2      Han    Nja\n3    Darth Dårlig\n\n\nMen her bruker jeg jo = som assignment. Hva skjer?\nPoenget her er at jeg bruker = inni funksjonens argumenter. data.frame() er en funksjon, og jeg definerer her hva som skal være kolonnene i datasettet mitt. Så bruker jeg <- til å assigne det som funksjonen data.frame() returnerer. Forvirra? På generelt grunnlag kan vi si at vi bruker = inni funksjoner, og <- utafor4.\nForresten, hvorfor prøver vi ikke bare å bruke <- inni funksjonen og ser hva som skjer?\n\n# Funker ikke\ndat1x <- data.frame(\n  personer <- c(\"Luke\", \"Han\", \"Darth\"),\n  moral <- c(\"Bra\", \"Nja\", \"Dårlig\")\n)\n\ndat1\n\n  personer  moral\n1     Luke    Bra\n2      Han    Nja\n3    Darth Dårlig\n\ndat1x\n\n  personer....c..Luke....Han....Darth.. moral....c..Bra....Nja....Dårlig..\n1                                  Luke                                Bra\n2                                   Han                                Nja\n3                                 Darth                             Dårlig\n\n\nHvis vi sammenlikner de to datasetta ser vi at det funker … på en måte. Oppsettet blir likt, men vi mister navnet på kolonnene."
  },
  {
    "objectID": "import-export.html#felles-mønstre",
    "href": "import-export.html#felles-mønstre",
    "title": "5  Import og eksport av data",
    "section": "5.1 Felles mønstre",
    "text": "5.1 Felles mønstre\nImportering og eksportering henger sammen, så vi kan omtale dem samtidig. Det er større forskjell på de ulike formatene vi håndterer, så vi organiserer oss etter dem. Imidlertid er det noen grunnleggende mønstre vi kan diskutere felles.\nDe fleste importeringsfunksjoner kalles noe med read, fordi de leser inn filer. Dermed blir eksporteringsfunksjoner write, fordi de skriver filer til disken.\n\n5.1.1 Filnavn\nVi må ofte definere et navn på fila vi skal skrive eller lese. Når vi leser filer, vil navnet ofte bety både\n\nhva heter fila og\nhvor ligger fila lagra\n\nDette er fordi et filnavn strengt tatt inkludere hele filstien til fila. Den fila jeg arbeider på nå heter f.eks. import-export.qmd. Den ligger på dette filområdet på datamaskina mi: C:/Users/HK2Q/Documents/r/dokumentasjon. Dermed blir det egentlige navnet på fila: C:/Users/HK2Q/Documents/r/dokumentasjon/import-export.qmd. Husk at også filtutvidelsen (det som kommer ettter .) er en del av filnavnet! Når en funksjon ber om file eller path betyr dette ofte at de vil ha hele det fulle filnavnet inkludert filsti.\n\n\n5.1.2 Relative fillokasjoner\nMan kan alltids henvise til konkrete områder på maskina, men dette er optimalt fordi det gjør at du aldri kan flytte noen filer igjen. Dessuten vil ikke koden funke på en annen persons PC med mindre de har 100 % likt oppsett på deres maskin. Derfor er det nyttig med relative filstier. Når du arbeider i Rstudio (og du er ikke en gærning som arbeider i R GUI, er du vel?) forventes det at du arbeider i såkalte prosjekter. Alle mine prosjekter ligger kopiert på M:-disken. Et prosjekt er en mappe med visse filer i seg, hvorav den viktige fila er prosjekt_navn.Rproj. Denne opprettes automatisk når du lager et prosjekt via Rstudio. Det er mange flotte ting med prosjekter, og en av dem er at alle filstier defineres ut fra prosjektets rotmappe. Rotmappa er den mappa hvor .Rproj-filer ligger, og der du putter alle mapper og filer assosiert med prosjektet. Når du arbeider i prosjekter trenger du ikke definere hele filstien til en fil, bare hvor den ligger i forhold til rotmappa. F.eks. har jeg for denne boka lagt alle bilder i en mappe som heter img. Hvis jeg vil henvise til et bilde skrive jeg bare img/bilde.png. Gjør det til en vane å bruke relative filstier når du kan!\nDet går så klart ikke alltid. Når noe ligger på f.eks. M:-disken må jeg lage en full filsti. Fordelen er at M: er en delt disk, så jeg kan anta at filstien vil se likt ut for andre.\nMerk at i noen tilfeller brytes antakelsen om at filstien alltid er relativt til rotmappa. I disse tilfellene er pakka here svært nyttig. Den er også nyttig på grunn av noe annet, nemlig skråstrekproblematikken\n\n\n\n5.1.3 Skråstreker til besvær\nI Windows brukes denne skråstreket \\ til å indikere ei mappe. I alle UNIX-baserte operativsystemet og programmer brukes /. Eksempler på sistnevnte er Ubuntu, macOS, og R. Når vi arbeider med R på Windows skjer det dermed en del arbeid i kulissene når vi henviser til en filplassering. Dette blir åpenbart for oss når vi for eksempel forsøker å lime inn en filsti fra Windows explorer (filutforskeren). R godtar ikke uten videre “feil” skråstrek. Det er to løsninger på dette:\n\nendre skråstrekene så de går andre vei\nescape skråstrekene\n\nDet siste innebærer å bruke det som kalles escape characters. En del tegn har meninger i koden. F.eks. betyr # kommentar i et R-skript. Hvis jeg vil skrive ut emneknaggen, må jeg legge på en escape character så R skjønner at dette tegnet skal ikke skal tolkes slik det vanligvis tolkes. Hva er escape-tegnet? Det er nettopp \\. For å escape # skriver vi dermed \\#, og for å escape \\ skriver vi altså \\\\.\n\n# Ok\n\"C:/Users/HK2Q/Documents/r/dokumentasjon\"\n\n# Ikke ok\n\"C:\\Users\\HK2Q\\Documents\\r\\dokumentasjon\"\n\n# Ok\n\"C:\\\\Users\\\\HK2Q\\\\Documents\\\\r\\\\dokumentasjon\"\n\nEn kjapp måte å få skråstrekene etter å ha kopiert en filsti i Windows er følgende\n\n# Skriver ut filsti med esaped `\\` til konsollen. Funksjonen leser \n# innholdet i utklippstavla og limer det inn i konsollen.\npaste0(readClipboard())\n\nAlt dette for å si: here pakka løser en del av problema våre. Les mer om den på Ode to the here package.\n\n\n5.1.4 Tegnkoding\nSpesielt når det kommer til norske .csv-filer hender det vi får et problem med tegnkodinga (character encoding). En full gjennomgang blir for omfattende. Det holder å si at, igjen, dette er hovedsaklig et Windows-problem. Ideelt sett vil vi ha alt over i unicode (UTF-8). Noen filer er lagra i et annet format. Gjerne ISO8859-1 som er en av standardene som gir oss skandinaviske tegn. En forkludrende faktor er at det tidvis (og inntil ganske nylig, per 2023-03) har vært problemer med R og/eller Rstudio når det kommer til tegnkoding. Disse blir fiksa med tida og er kanskje allerede fiksa. Du ser problemet dukke opp dersom du forventer å se en æ. ø eller å i outputen og istedet får noe sånt som \"\\xe6\\xf8\\xe5\", Ã¦Ã¸Ã¥ eller <U+00C6>. Der er mange ulike faktorer som kan være årsak til dette problemet. En av dem kan være at du må sette tegnkoden spesifikt når du leser en fil. I noen av eksemplene mine vil du set at jeg har spesifisert encoding, og da er det derfor."
  },
  {
    "objectID": "import-export.html#tekstfiler-csv-med-familie",
    "href": "import-export.html#tekstfiler-csv-med-familie",
    "title": "5  Import og eksport av data",
    "section": "5.2 Tekstfiler (csv med familie)",
    "text": "5.2 Tekstfiler (csv med familie)\nVi kan bruke read.csv() fra utils, en av pakkene som lastes når vi starter R. Det finnes også noen funksjoner fra readr, en del av, 100 poeng til den som gjetter rett, tidyverse. Herfra får vi read_csv(), read_csv2(), read_tsv() og read_delim(). Les dokumentasjon for å finne mer informasjon om dem. Kort fortalt er forskjellen at alle tre er implementeringer av den mer generelle _delim(). La oss skrive en fil og deretter last den inn.\n\n# Dette datasettet ligger klart når vi laster inn R.\nmtcars\n\n# La oss lagre det som en csv-fil\nmtcars %>% \n  write_csv(file = here(\"data\", \"mtcars.csv\"))\n\n\n# Og så laster vi den inn igjen\nbiler <- read_csv(file = here(\"data\", \"mtcars.csv\"), name_repair = \"universal\")\n\nRows: 32 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (11): mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nbiler\n\n# A tibble: 32 × 11\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# … with 22 more rows\n\n\nJeg foretrekker readrs funksjoner fordi de har mange nyttige alternativer slik som name_repair = \"universal\". Denne passer på at navna i datasettet er på et format som R tolererer. F.eks. at de ikke har mellomrom i seg. Veldig nyttig. Med na = kan du fortelle R hvordan missing er lagra i fila du importerer."
  },
  {
    "objectID": "import-export.html#spss",
    "href": "import-export.html#spss",
    "title": "5  Import og eksport av data",
    "section": "5.3 SPSS",
    "text": "5.3 SPSS\nFor SPSS-filer bruker vi pakka haven. Denne pakka er en del av … ja, du skjønner.\n\nlibrary(haven)\n# Lagrer en fil som en spss-fil. (Jeg lagrer bare de første fire kolonnene).\nstarwars %>% \n  select(1:4) %>% \n  write_sav(here(\"data\", \"starwars.sav\"))\n\n\n# Les inn en spss-fil\nstjernekrig <- read_sav(here(\"data\", \"starwars.sav\"), .name_repair = \"universal\")\nstjernekrig %>% head()\n\n# A tibble: 6 × 4\n  name           height  mass hair_color   \n  <chr>           <dbl> <dbl> <chr>        \n1 Luke Skywalker    172    77 \"blond\"      \n2 C-3PO             167    75 \"\"           \n3 R2-D2              96    32 \"\"           \n4 Darth Vader       202   136 \"none\"       \n5 Leia Organa       150    49 \"brown\"      \n6 Owen Lars         178   120 \"brown, grey\"\n\n\nLegger du merke til noe med fila over? Hva om jeg printer ut de tilsvarende kolonner fra det opprinnelige datasettet vårt?\n\nstarwars %>% \n  select(1:4) %>% \n  head()\n\n# A tibble: 6 × 4\n  name           height  mass hair_color \n  <chr>           <int> <dbl> <chr>      \n1 Luke Skywalker    172    77 blond      \n2 C-3PO             167    75 <NA>       \n3 R2-D2              96    32 <NA>       \n4 Darth Vader       202   136 none       \n5 Leia Organa       150    49 brown      \n6 Owen Lars         178   120 brown, grey\n\n\nHårfarge har mista NA-designasjonen. Nå er de som før var missing bare tomme. Dette kan skape hodebry for oss seinere, så det er bra vi oppdaga det nå.\nFor å være helt ærlig er jeg ikke sikker på hvordan man løser dette direkte. Feilen oppstår enten når vi eksporterer til .sav eller importerer tilbake til R. Kanskje finnes det et svar i Havens dokumentasjon. Imidlertid er det lett å omgå problemet i ettertid:\n\n# Lag ny versjon av hårfarge. Hvis hårfarge er tom (\"\"), bli missing. Ellers, \n# bli det du allerede er. \nstjernekrig <- stjernekrig %>% \n  mutate(\n    hair_color = if_else(\n      hair_color == \"\", \n      NA_character_, \n      hair_color)\n    )\nstjernekrig %>% head()\n\n# A tibble: 6 × 4\n  name           height  mass hair_color \n  <chr>           <dbl> <dbl> <chr>      \n1 Luke Skywalker    172    77 blond      \n2 C-3PO             167    75 <NA>       \n3 R2-D2              96    32 <NA>       \n4 Darth Vader       202   136 none       \n5 Leia Organa       150    49 brown      \n6 Owen Lars         178   120 brown, grey\n\n\nHvorfor NA_character_ og ikke bare NA? if_else forventer at alle argumentene skal være av samme type/klasse. Derfor må til og med NA være en spesiell type NA. Siden hair_color er en strengvektor, må NA være en streng-NA.\nNår vi laster inn SPSS-filer vil vi ofte få med merkelappene (labels) derfra også, i form av attributter. tidyverse-pakker talker ofte dette og viser dem når vi printer objektene. Noen ganger har jeg opplevd, med andre pakker, at attributtene ikke kan leses. I så fall kan man bare fjerne dem."
  },
  {
    "objectID": "import-export.html#excel",
    "href": "import-export.html#excel",
    "title": "5  Import og eksport av data",
    "section": "5.4 Excel",
    "text": "5.4 Excel\nJeg er unødvendig streng mot Excel fordi jeg gjerne vil ha ut en enkel datastruktur fra Excels filer, mens Excel tillater oss kompliserte strukturer som ikke uten videre kan puttes inn en en vanlig tabell. Som sagt er vi her avhengig av den enkelte person som lagde Excelfila når det kommer til hvor lett det er for oss å laste den inn. Det å være konsekvent er viktigere enn å etterlikne en “vanlig tabell”. Til dette arbeidet har vi to pakker som har ulike bruksområder:\n\nopenxlsx: Kilde. Brukes for å skrive Excel-filer.\nreadxl: Kilde. Brukes for å lese Excel-filer.\n\n\n5.4.1 Skrive til Excel: openxlsx\nPakkas egen introduksjon er en god guide til hvordan dette funker. Sjekk den ut. I korte drag:\n\nlibrary(openxlsx)\n\n# Kjapp lagring av fil\nstarwars %>% write.xlsx()\n\n# Hvis du vil ha det som en tabell \nstarwars %>% write.xlsx(asTable = TRUE)\n\nHer ser vi forøvrig en demonstrasjon av hvordan et argument er valgfritt fordi det er definert en default-verdi. I definisjonen av write.xlsx() står det at argumentet asTable er satt til FALSE. Dermed trenger vi ikke spesifisere dette med mindre vi vil endre den til noe annet, slik vi gjør i siste linje.\nMan kan også bygge opp en excelfil mer gradvis\n\nlibrary(openxlsx)\n\n# Start med å lage et workbook-objekt\nwb <- createWorkbook()\n\n# Legg til (tomme) arkfaner\naddWorksheet(wb, sheetName = \"Motor Trend Car Road Tests\", gridLines = FALSE)\naddWorksheet(wb, sheetName = \"Iris\", gridLines = FALSE)\n\n# Skriv data til disse arkfanene. `mtcars` og `iris` er datasett som ligger i R.\nwriteDataTable(wb, sheet = 1, x = mtcars, colNames = TRUE, rowNames = TRUE, \n               tableStyle = \"TableStyleLight9\")\nwriteDataTable(wb, sheet = 2, iris, startCol = \"K\", startRow = 2)\n\n# Lagre fila som excel-fil.\nsaveWorkbook(wb, here(\"data\", \"basics.xlsx\"), overwrite = TRUE)\n\nDette lar deg spesifisere flere av de grafiske elementa i excel-fila, blant annet.\nEn apropos, dersom du har mestra pipa (%>%): Man kan ikke uten videre pipe sammen de forskjellige kommandoene i denne pakka slik man kan med datasett. Dette gir feil:\n\n# Start med å lage et workbook-objekt\nwb <- createWorkbook()\n\n# Legg til (tomme) arkfaner\naddWorksheet(wb, sheetName = \"Motor Trend Car Road Tests\", gridLines = FALSE) %>% \n  addWorksheet(sheetName = \"Iris\", gridLines = FALSE)\n\nError: wb must be a Workbok\n\n\nHer ser vi altså en begrensing ved tidyverse: Når du bruker pakker som ikke er en del av universet deres kan vi måtte gjøre endringer i arbeidsflyten vår.\n\n\n5.4.2 Lese Excel-filer: readxl\nDenne pakka er en del av tidyverse, så her er det bare å stappe pipa.\nLa oss ta et steg tilbake og tenke på vi må gjøre når vi leser inn Excel-filer. Det er en del konsepter i Excel som ikke finnes eller brukes i R:\n\ntomme rader og kolonner som rammer: Det vi ser som en tom celle i Excel er ikke nødvendigvis at den eksisterer. La oss ikke bli for filosofisk her. Pakkas tekst om regnearkgeometri forklarer dette bedre enn jeg kan.\nfarger som indikerer et eller annet om en rad, kolonne eller celle: Dette pleier jeg se bort fra. Viktig informasjon om rader kan heller lagres i tekstformat, i f.eks. en .Rmd/.qmd-fil.\nfunksjoner: i R definerer vi funksjonene og kjører dem en gang. Funksjonene blir liggende som objekter i miljøet/skriptet, mens verdiene de produserer blir putta i datasettet. I Excel blir funksjonen og resultatet liggende i samme celle, oppå hverandre. Når vi laster inn fila er vi bare interessert i sjølve resultatene av funksjonen heller enn funksjonen i seg sjøl.\nsammenslåtte celler: Disse er spesielt vanskelig. Ifg. denne posten på StackOverflow kan man bruke openxlsx for å lese slike filer. Hvis det gjelder noen få celler, f.eks. i overskrifter, ville jeg vurdert å heller manuelt gå inn og dele dem opp igjen.\n\nVi kan bruke read_excel() fra readxl til å lese inn Excel-filer. Den lar oss definere en hel del nyttige ting. Her har jeg limt inn funksjonen med alle argumentene, så forkalrer jeg i en kommentar hva de gjør\n\nlibrary(readxl)\n\nread_excel(\n  path, # Filsti + navn på fila du skal lese\n  sheet = NULL, # Hvilke(t) regneark. Enten navn eller indeks\n  range = NULL, # Celler du vil lese. I Excels format, f.eks. \"B3:D87\"\n  col_names = TRUE, # Er første linje kolonnenavn?\n  col_types = NULL, # Definer hvilke klasser/typer hver kolonne skal lagres som\n  na = \"\", # Hvis NA er lagra som noe annet enn en tom celle, skriv det her\n  trim_ws = TRUE, # Automatisk fjerning av whitespace\n  skip = 0, \n  n_max = Inf,\n  guess_max = min(1000, n_max), # Se ned\n  progress = readxl_progress(),\n  .name_repair = \"unique\" \n)\n\nOm guess_max: Hvis du ikke definerer col_types vil funksjonen gjette på hvilken type data hver kolonne inneholder. På generelt plan er Excel god på dette. Den sliter hvis:\n\nei kolonne inneholder flere enn en type og\ndet er mange tomme celler i starten av ei kolonne\n\nDet står mer om gjettinga i Cell and Column Types. Angående punkt 2: dette var et problem i barnehagekapasitetsarbeidet. Her lasta jeg inn noen områder i ei Excel-fil som hadde mange tomme rader før det dukka opp en verdi. I disse tilfellene kunne jeg få feilmelding fordi funksjonen forventa en annen type verdi enn det den fant. Løsninga blei å spesifisere kolonnetypen med col_types."
  },
  {
    "objectID": "inspisere.html#view",
    "href": "inspisere.html#view",
    "title": "6  Inspisere data",
    "section": "6.1 View",
    "text": "6.1 View\nKommandoen View() gir deg det nærmeste vi kommer SPSS’ Data view-vindu. Her kan du se rader, celler og kolonner. Merk at kommandoen har stor forbokstav - noe som er uvanlig. Du bruker det simpelthen slik View(starwars), og et nytt vindu vil dukke opp hvor du kan bivåne data i ro og mak. Har du store mengder data er min erfaring at scrollinga blir litt treig, og det tar litt tid å laste inn hvert nye skjermbilde. Hvis du er lei av å skrive, kan du også dobbeltklikke på et data.frame/tibble-objekt i miljø-vinduet."
  },
  {
    "objectID": "inspisere.html#del-inspisering",
    "href": "inspisere.html#del-inspisering",
    "title": "6  Inspisere data",
    "section": "6.2 Del-inspisering",
    "text": "6.2 Del-inspisering\nDen enkleste måten å inspisere et datasett på er å bare skrive navnet i konsollen. Da blir (et utdrag) av datasettet skrevet ut.\n\n# For å gjøre disse eksemplene tydligere legger jeg på en rad-ID med \n# `rowid_to_column()` slik at vi lettere ser hvilken rad vi ser på.\n# Datasettet har biltype som \"radnavn\", så vi putter disse inn i en egen\n# kolonne først med `rownames_to_column()`.\nbiler <- mtcars %>% \n  rownames_to_column(\"bil\") %>% \n  rowid_to_column(\"rowid\")\n\nbiler\n\n   rowid                 bil  mpg cyl  disp  hp drat    wt  qsec vs am gear\n1      1           Mazda RX4 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4\n2      2       Mazda RX4 Wag 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4\n3      3          Datsun 710 22.8   4 108.0  93 3.85 2.320 18.61  1  1    4\n4      4      Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3\n5      5   Hornet Sportabout 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3\n6      6             Valiant 18.1   6 225.0 105 2.76 3.460 20.22  1  0    3\n7      7          Duster 360 14.3   8 360.0 245 3.21 3.570 15.84  0  0    3\n8      8           Merc 240D 24.4   4 146.7  62 3.69 3.190 20.00  1  0    4\n9      9            Merc 230 22.8   4 140.8  95 3.92 3.150 22.90  1  0    4\n10    10            Merc 280 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4\n11    11           Merc 280C 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4\n12    12          Merc 450SE 16.4   8 275.8 180 3.07 4.070 17.40  0  0    3\n13    13          Merc 450SL 17.3   8 275.8 180 3.07 3.730 17.60  0  0    3\n14    14         Merc 450SLC 15.2   8 275.8 180 3.07 3.780 18.00  0  0    3\n15    15  Cadillac Fleetwood 10.4   8 472.0 205 2.93 5.250 17.98  0  0    3\n16    16 Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3\n17    17   Chrysler Imperial 14.7   8 440.0 230 3.23 5.345 17.42  0  0    3\n18    18            Fiat 128 32.4   4  78.7  66 4.08 2.200 19.47  1  1    4\n19    19         Honda Civic 30.4   4  75.7  52 4.93 1.615 18.52  1  1    4\n20    20      Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4\n21    21       Toyota Corona 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3\n22    22    Dodge Challenger 15.5   8 318.0 150 2.76 3.520 16.87  0  0    3\n23    23         AMC Javelin 15.2   8 304.0 150 3.15 3.435 17.30  0  0    3\n24    24          Camaro Z28 13.3   8 350.0 245 3.73 3.840 15.41  0  0    3\n25    25    Pontiac Firebird 19.2   8 400.0 175 3.08 3.845 17.05  0  0    3\n26    26           Fiat X1-9 27.3   4  79.0  66 4.08 1.935 18.90  1  1    4\n27    27       Porsche 914-2 26.0   4 120.3  91 4.43 2.140 16.70  0  1    5\n28    28        Lotus Europa 30.4   4  95.1 113 3.77 1.513 16.90  1  1    5\n29    29      Ford Pantera L 15.8   8 351.0 264 4.22 3.170 14.50  0  1    5\n30    30        Ferrari Dino 19.7   6 145.0 175 3.62 2.770 15.50  0  1    5\n31    31       Maserati Bora 15.0   8 301.0 335 3.54 3.570 14.60  0  1    5\n32    32          Volvo 142E 21.4   4 121.0 109 4.11 2.780 18.60  1  1    4\n   carb\n1     4\n2     4\n3     1\n4     1\n5     2\n6     1\n7     4\n8     2\n9     2\n10    4\n11    4\n12    3\n13    3\n14    3\n15    4\n16    4\n17    4\n18    1\n19    2\n20    1\n21    1\n22    2\n23    2\n24    4\n25    2\n26    1\n27    2\n28    2\n29    4\n30    6\n31    8\n32    2\n\n\nI seg sjøl greit. Men man risikerer å overse noe dersom man alltid bare inspiserer de øverste ti radene. Da er de nyttig å se på et tilfeldig utvalg av rader\n\nbiler %>% slice_sample(n = 10)\n\n   rowid                bil  mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n1     20     Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n2      4     Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n3     18           Fiat 128 32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n4     31      Maserati Bora 15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n5     19        Honda Civic 30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n6      9           Merc 230 22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n7      2      Mazda RX4 Wag 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n8     17  Chrysler Imperial 14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n9     15 Cadillac Fleetwood 10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n10    10           Merc 280 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n\n\nDenne funksjonen er en avart av slice() som gir deg spesifikke rader. Hvis du f.eks. vil ha rad 10-20:\n\nbiler %>% slice(10:20)\n\n   rowid                 bil  mpg cyl  disp  hp drat    wt  qsec vs am gear\n1     10            Merc 280 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4\n2     11           Merc 280C 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4\n3     12          Merc 450SE 16.4   8 275.8 180 3.07 4.070 17.40  0  0    3\n4     13          Merc 450SL 17.3   8 275.8 180 3.07 3.730 17.60  0  0    3\n5     14         Merc 450SLC 15.2   8 275.8 180 3.07 3.780 18.00  0  0    3\n6     15  Cadillac Fleetwood 10.4   8 472.0 205 2.93 5.250 17.98  0  0    3\n7     16 Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3\n8     17   Chrysler Imperial 14.7   8 440.0 230 3.23 5.345 17.42  0  0    3\n9     18            Fiat 128 32.4   4  78.7  66 4.08 2.200 19.47  1  1    4\n10    19         Honda Civic 30.4   4  75.7  52 4.93 1.615 18.52  1  1    4\n11    20      Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4\n   carb\n1     4\n2     4\n3     3\n4     3\n5     3\n6     4\n7     4\n8     4\n9     1\n10    2\n11    1\n\n\nDette gir oss en mulighet til å se fordelen med å arbeide med tibbles: På noen skjermer blir den forrige tabellen stygg fordi den siste kolonna presses ned til ei ny side. (Jeg kan ikke garantere at det skjer på din side.) Men om vi gjør om biler (som arver data.fram-klassen fra mtcars) til en tibble, får den siste kolonna plass på samme linje som resten. (Jeg kan forsåvidt heller ikke garantere at dette vil se helt likt ut på din skjerm.) Og vi får vite kolonnetypen til hver kolonne. Stilig!\n\nbiler %>% \n  tibble() %>% \n  slice(10:20)\n\n# A tibble: 11 × 13\n   rowid bil     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <int> <chr> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1    10 Merc…  19.2     6 168.    123  3.92  3.44  18.3     1     0     4     4\n 2    11 Merc…  17.8     6 168.    123  3.92  3.44  18.9     1     0     4     4\n 3    12 Merc…  16.4     8 276.    180  3.07  4.07  17.4     0     0     3     3\n 4    13 Merc…  17.3     8 276.    180  3.07  3.73  17.6     0     0     3     3\n 5    14 Merc…  15.2     8 276.    180  3.07  3.78  18       0     0     3     3\n 6    15 Cadi…  10.4     8 472     205  2.93  5.25  18.0     0     0     3     4\n 7    16 Linc…  10.4     8 460     215  3     5.42  17.8     0     0     3     4\n 8    17 Chry…  14.7     8 440     230  3.23  5.34  17.4     0     0     3     4\n 9    18 Fiat…  32.4     4  78.7    66  4.08  2.2   19.5     1     1     4     1\n10    19 Hond…  30.4     4  75.7    52  4.93  1.62  18.5     1     1     4     2\n11    20 Toyo…  33.9     4  71.1    65  4.22  1.84  19.9     1     1     4     1\n\n\nNoen ganger er det likevel nyttig å kikke på toppen eller bunnen av et datasett. Da kan vi bruke de komplementære funksjonene head() og tail().\n\n# `head()` viser toppen\nbiler %>% head()\n\n  rowid               bil  mpg cyl disp  hp drat    wt  qsec vs am gear carb\n1     1         Mazda RX4 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n2     2     Mazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n3     3        Datsun 710 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n4     4    Hornet 4 Drive 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n5     5 Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n6     6           Valiant 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n# `tail()` viser bunnen\nbiler %>% tail()\n\n   rowid            bil  mpg cyl  disp  hp drat    wt qsec vs am gear carb\n27    27  Porsche 914-2 26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2\n28    28   Lotus Europa 30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\n29    29 Ford Pantera L 15.8   8 351.0 264 4.22 3.170 14.5  0  1    5    4\n30    30   Ferrari Dino 19.7   6 145.0 175 3.62 2.770 15.5  0  1    5    6\n31    31  Maserati Bora 15.0   8 301.0 335 3.54 3.570 14.6  0  1    5    8\n32    32     Volvo 142E 21.4   4 121.0 109 4.11 2.780 18.6  1  1    4    2\n\n\nDisse er nyttig fordi de kan brukes på mer enn bare datasett.\n\n# Viser de siste kolonnenavna i datasettet\nbiler %>% \n  colnames() %>% \n  tail()\n\n[1] \"wt\"   \"qsec\" \"vs\"   \"am\"   \"gear\" \"carb\"\n\n# Lager en strengvektor på 26 elementer (bokstaver)\nbokstaver <- letters[1:26]\n\n# Viser de siste bokstavene\nbokstaver %>% tail()\n\n[1] \"u\" \"v\" \"w\" \"x\" \"y\" \"z\""
  },
  {
    "objectID": "inspisere.html#andre-kolonner",
    "href": "inspisere.html#andre-kolonner",
    "title": "6  Inspisere data",
    "section": "6.3 Andre kolonner",
    "text": "6.3 Andre kolonner\nPå samme måte som det er begrensende å hele tida kikke på de øverste radene av et datasett er det begrensende å kikke på de fremste kolonnene. Vi kan bruke select() for å velge hvilke rader vi vil se på, eller vi kan bruke den nyttige glimpse(). Greier du å gjette hvor disse funksjonene kommer fra? De kommer fra dplyr!\n…\nsom er en del av tidyverse.\n\n6.3.1 select\nselect() gir oss muligheten til å diskutere en av de fantastiske innovasjonene i tidyverse: tidy evaluation. Vi dykker ikke dypt i det, men det er greit å vite om data masking og tidy select. De er diskutert mer inngående i Programming with Tidyverse. Tidy select lar oss velge en kolonne i et datasett uten å måtte hermetegn. Tenk på det! Neste gang du velger en kolonne slipper du å strekke lillefingeren til den fjerne shift-tasten og gå i spagat med langefingern til 2-tasten. Faktisk gjør tidy select mye mer enn dette, som vi vil se etter hvert. F.eks. kan du velge kolonner ut fra navn, posisjon, eller type. La oss se noen eksempler\n\n# Slik ser starwars-datasettet ut. \nstarwars %>% head()\n\n# A tibble: 6 × 14\n  name         height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵\n  <chr>         <int> <dbl> <chr>   <chr>   <chr>     <dbl> <chr> <chr>  <chr>  \n1 Luke Skywal…    172    77 blond   fair    blue       19   male  mascu… Tatooi…\n2 C-3PO           167    75 <NA>    gold    yellow    112   none  mascu… Tatooi…\n3 R2-D2            96    32 <NA>    white,… red        33   none  mascu… Naboo  \n4 Darth Vader     202   136 none    white   yellow     41.9 male  mascu… Tatooi…\n5 Leia Organa     150    49 brown   light   brown      19   fema… femin… Aldera…\n6 Owen Lars       178   120 brown,… light   blue       52   male  mascu… Tatooi…\n# … with 4 more variables: species <chr>, films <list>, vehicles <list>,\n#   starships <list>, and abbreviated variable names ¹​hair_color, ²​skin_color,\n#   ³​eye_color, ⁴​birth_year, ⁵​homeworld\n\n# Det er 14 kolonner. \n# Med mindre du har en svær skjerm kan vi ikke se alle på en gang.\nstarwars %>% colnames()\n\n [1] \"name\"       \"height\"     \"mass\"       \"hair_color\" \"skin_color\"\n [6] \"eye_color\"  \"birth_year\" \"sex\"        \"gender\"     \"homeworld\" \n[11] \"species\"    \"films\"      \"vehicles\"   \"starships\" \n\n# Vi kikker på noen spesifikke kolonner. \n# Films er ei liste, så den ser vi ikke direkte.\nstarwars %>% select(name, species, films)\n\n# A tibble: 87 × 3\n   name               species films    \n   <chr>              <chr>   <list>   \n 1 Luke Skywalker     Human   <chr [5]>\n 2 C-3PO              Droid   <chr [6]>\n 3 R2-D2              Droid   <chr [7]>\n 4 Darth Vader        Human   <chr [4]>\n 5 Leia Organa        Human   <chr [5]>\n 6 Owen Lars          Human   <chr [3]>\n 7 Beru Whitesun lars Human   <chr [3]>\n 8 R5-D4              Droid   <chr [1]>\n 9 Biggs Darklighter  Human   <chr [1]>\n10 Obi-Wan Kenobi     Human   <chr [6]>\n# … with 77 more rows\n\n# Vi vil ha 1, 3, 5, og 7 kolonne\nstarwars %>% select(1, 3, 5, 7)\n\n# A tibble: 87 × 4\n   name                mass skin_color  birth_year\n   <chr>              <dbl> <chr>            <dbl>\n 1 Luke Skywalker        77 fair              19  \n 2 C-3PO                 75 gold             112  \n 3 R2-D2                 32 white, blue       33  \n 4 Darth Vader          136 white             41.9\n 5 Leia Organa           49 light             19  \n 6 Owen Lars            120 light             52  \n 7 Beru Whitesun lars    75 light             47  \n 8 R5-D4                 32 white, red        NA  \n 9 Biggs Darklighter     84 light             24  \n10 Obi-Wan Kenobi        77 fair              57  \n# … with 77 more rows\n\n# Alle kolonner som inneholder en viss tekststreng\nstarwars %>% select(contains(\"color\"))\n\n# A tibble: 87 × 3\n   hair_color    skin_color  eye_color\n   <chr>         <chr>       <chr>    \n 1 blond         fair        blue     \n 2 <NA>          gold        yellow   \n 3 <NA>          white, blue red      \n 4 none          white       yellow   \n 5 brown         light       brown    \n 6 brown, grey   light       blue     \n 7 brown         light       blue     \n 8 <NA>          white, red  red      \n 9 black         light       brown    \n10 auburn, white fair        blue-gray\n# … with 77 more rows\n\n# Alle kolonner som er numeriske\nstarwars %>% select(where(is.numeric))\n\n# A tibble: 87 × 3\n   height  mass birth_year\n    <int> <dbl>      <dbl>\n 1    172    77       19  \n 2    167    75      112  \n 3     96    32       33  \n 4    202   136       41.9\n 5    150    49       19  \n 6    178   120       52  \n 7    165    75       47  \n 8     97    32       NA  \n 9    183    84       24  \n10    182    77       57  \n# … with 77 more rows\n\n\n\n\n6.3.2 glimpse\nTilbake til det opprinnelige formålet, som bare var å ta en kjapp titt på dataene vi har. Til dette er glimpse() utmerka. Den snur rett og slett datasettet 90 grader og skriver ut kolonnenavna nedover. Dermed får du med flere. Du får også en oversikt over hva hver kolonne inneholder, skjønt det er mer utydelig hva som er på samme rad. En fordel med glimpse() er at den viser oss innholdet i lister som er element av datasettet. Her ser vi f.eks. innholdet i kolonna films .\n\nstarwars %>% glimpse()\n\nRows: 87\nColumns: 14\n$ name       <chr> \"Luke Skywalker\", \"C-3PO\", \"R2-D2\", \"Darth Vader\", \"Leia Or…\n$ height     <int> 172, 167, 96, 202, 150, 178, 165, 97, 183, 182, 188, 180, 2…\n$ mass       <dbl> 77.0, 75.0, 32.0, 136.0, 49.0, 120.0, 75.0, 32.0, 84.0, 77.…\n$ hair_color <chr> \"blond\", NA, NA, \"none\", \"brown\", \"brown, grey\", \"brown\", N…\n$ skin_color <chr> \"fair\", \"gold\", \"white, blue\", \"white\", \"light\", \"light\", \"…\n$ eye_color  <chr> \"blue\", \"yellow\", \"red\", \"yellow\", \"brown\", \"blue\", \"blue\",…\n$ birth_year <dbl> 19.0, 112.0, 33.0, 41.9, 19.0, 52.0, 47.0, NA, 24.0, 57.0, …\n$ sex        <chr> \"male\", \"none\", \"none\", \"male\", \"female\", \"male\", \"female\",…\n$ gender     <chr> \"masculine\", \"masculine\", \"masculine\", \"masculine\", \"femini…\n$ homeworld  <chr> \"Tatooine\", \"Tatooine\", \"Naboo\", \"Tatooine\", \"Alderaan\", \"T…\n$ species    <chr> \"Human\", \"Droid\", \"Droid\", \"Human\", \"Human\", \"Human\", \"Huma…\n$ films      <list> <\"The Empire Strikes Back\", \"Revenge of the Sith\", \"Return…\n$ vehicles   <list> <\"Snowspeeder\", \"Imperial Speeder Bike\">, <>, <>, <>, \"Imp…\n$ starships  <list> <\"X-wing\", \"Imperial shuttle\">, <>, <>, \"TIE Advanced x1\",…"
  },
  {
    "objectID": "inspisere.html#sec-oppsummering",
    "href": "inspisere.html#sec-oppsummering",
    "title": "6  Inspisere data",
    "section": "6.4 Oppsummeringer",
    "text": "6.4 Oppsummeringer\nHittil har vi bare prata om måter å set utdrag av data på. Noen ganger er det nyttig å se en oppsummering av dataene. Detaljer som snitt, standardavvik, minimum og maksimum-verdier, for eksempel.\nsummary() fra base R er nyttig her. Den gir enkelt og greit en oversikt over diverse statistikk for hver numeriske variabel.\n\nbiler %>% summary()\n\n     rowid           bil                 mpg             cyl       \n Min.   : 1.00   Length:32          Min.   :10.40   Min.   :4.000  \n 1st Qu.: 8.75   Class :character   1st Qu.:15.43   1st Qu.:4.000  \n Median :16.50   Mode  :character   Median :19.20   Median :6.000  \n Mean   :16.50                      Mean   :20.09   Mean   :6.188  \n 3rd Qu.:24.25                      3rd Qu.:22.80   3rd Qu.:8.000  \n Max.   :32.00                      Max.   :33.90   Max.   :8.000  \n      disp             hp             drat             wt       \n Min.   : 71.1   Min.   : 52.0   Min.   :2.760   Min.   :1.513  \n 1st Qu.:120.8   1st Qu.: 96.5   1st Qu.:3.080   1st Qu.:2.581  \n Median :196.3   Median :123.0   Median :3.695   Median :3.325  \n Mean   :230.7   Mean   :146.7   Mean   :3.597   Mean   :3.217  \n 3rd Qu.:326.0   3rd Qu.:180.0   3rd Qu.:3.920   3rd Qu.:3.610  \n Max.   :472.0   Max.   :335.0   Max.   :4.930   Max.   :5.424  \n      qsec             vs               am              gear      \n Min.   :14.50   Min.   :0.0000   Min.   :0.0000   Min.   :3.000  \n 1st Qu.:16.89   1st Qu.:0.0000   1st Qu.:0.0000   1st Qu.:3.000  \n Median :17.71   Median :0.0000   Median :0.0000   Median :4.000  \n Mean   :17.85   Mean   :0.4375   Mean   :0.4062   Mean   :3.688  \n 3rd Qu.:18.90   3rd Qu.:1.0000   3rd Qu.:1.0000   3rd Qu.:4.000  \n Max.   :22.90   Max.   :1.0000   Max.   :1.0000   Max.   :5.000  \n      carb      \n Min.   :1.000  \n 1st Qu.:2.000  \n Median :2.000  \n Mean   :2.812  \n 3rd Qu.:4.000  \n Max.   :8.000  \n\n\nVi kan også sette sammen vår eget sammendrag med summarise fra dplyr. Her kombinerer vi det med grupperingsfunksjonen group_by().\n\nmtcars %>% \n  group_by(cyl) %>% \n  summarise(\n    mpg_m = mean(mpg),\n    mpg_sd = sd(mpg)\n  )\n\n# A tibble: 3 × 3\n    cyl mpg_m mpg_sd\n  <dbl> <dbl>  <dbl>\n1     4  26.7   4.51\n2     6  19.7   1.45\n3     8  15.1   2.56\n\n\nTips: Jeg bruker både summary() og summarise() ofte. Og jeg bruker nesten konsekvent den ene når jeg egentlig mener å bruke den andre. Får du feilmelding når du arbeider med disse funksjonene, sjekk først at du ikke egentlig mente å bruke den andre."
  },
  {
    "objectID": "pivot.html#tidy-data",
    "href": "pivot.html#tidy-data",
    "title": "7  Omstrukturering av data (pivot)",
    "section": "7.1 Tidy data",
    "text": "7.1 Tidy data\nEn grundigere introduksjon finnes hos Tidyverse. Faktisk er det en mye bedre introduksjon enn det jeg hadde greid å skrive. Hvis du er interessert i hvorfor jeg hele tida maser på tidy data, og prinsippene bak det, sjekk ut lenka! Hvis du tar orda mine for gode fisker kan du nøye deg med denne definisjon av tidy data:\n\n\nHver kolonne er en variabel.\nHver rad er en observasjon.\nHver celle er én verdi.\n\n\n(Min oversettelse, fra lenka over.)\nSjøl om du ikke har hørt om tidy data før har du sikkert vært bort forskjellen på lange og vide formater i dag. Kanskje du ikke er vant med å bruke de orda om det, men du har nok vært borti behovet for å omstrukturere et datasett. Noen eksempler kan hjelpe til:\n\n# Genererer et datasett for illustrasjon\nprognose <- tibble(\n  plansone = rep(seq(5001001, 5001004), each = 2),\n  kjonn = rep(c(\"M\", \"K\"), 4),\n  aar2023 = round(runif(8, 400, 800)),\n  aar2024 = round(runif(8, 400, 800)),\n  aar2025 = round(runif(8, 400, 800)),\n)\nprognose\n\n# A tibble: 8 × 5\n  plansone kjonn aar2023 aar2024 aar2025\n     <int> <chr>   <dbl>   <dbl>   <dbl>\n1  5001001 M         541     708     412\n2  5001001 K         719     662     755\n3  5001002 M         458     553     791\n4  5001002 K         441     762     613\n5  5001003 M         518     667     428\n6  5001003 K         428     614     472\n7  5001004 M         555     467     776\n8  5001004 K         524     652     740\n\n\nHer har vi et datasett med fire plansoner, to kjønn, og tre variabler som viser forventa folkemengde fra 2023 til 2025. Vi kan se på de tre punktene og vurdere om dette er tidy data.\n\nEr hver kolonne en variabel? Plansone og kjønn ja. Årsvariabelene: kanskje? Det er forventa befolkning per år.\nEr hver rad en observasjon? Nei. Hver rad er tre observasjoner: en for hvert år.\n\nDermed vil vi gjøre om dette til et tidy format. Dette gjør vi ved å gå fra bredt til langt format. For å gjøre dette tar vi i bruk funksjoner fra tidyverse1."
  },
  {
    "objectID": "pivot.html#fra-vid-til-lang",
    "href": "pivot.html#fra-vid-til-lang",
    "title": "7  Omstrukturering av data (pivot)",
    "section": "7.2 Fra vid til lang",
    "text": "7.2 Fra vid til lang\nLa oss kikke på det å gå mellom lange og vide formater. Dette kan være vanskelig å se for seg. Jeg setter alltid pris på å ha noe visuelt å lene meg på. Her er en god illustrasjon fra Posits tidyr-jukselapp:\n\n\n\nFra bredt til langt og fra langt til bredt — CC BY SA Posit Software\n\n\nEn pivot: Vi velger de tre årskolonnene og sender navna deres til en ny variabel og verdiene deres til en annen. Disse navngir vi ved en streng. Slik kan det set ut\n\nprognose %>% \n  pivot_longer(cols = c(aar2023, aar2024, aar2025), \n               names_to = \"aar\", \n               values_to = \"befolkning\")\n\n# A tibble: 24 × 4\n   plansone kjonn aar     befolkning\n      <int> <chr> <chr>        <dbl>\n 1  5001001 M     aar2023        541\n 2  5001001 M     aar2024        708\n 3  5001001 M     aar2025        412\n 4  5001001 K     aar2023        719\n 5  5001001 K     aar2024        662\n 6  5001001 K     aar2025        755\n 7  5001002 M     aar2023        458\n 8  5001002 M     aar2024        553\n 9  5001002 M     aar2025        791\n10  5001002 K     aar2023        441\n# … with 14 more rows\n\n\nNå er datasettet tidy: hver rad representerer bare én observasjon. Vi oppnådde dette ved å gå fra vidt til langt format. Når det er sagt, har vi en del vi kunne ha utsatt på datasettet. Vi kan bruke det som eksempel på hvordan vi arbeider iterativt, ved å bygge videre på det vi starter med. Det jeg ikke liker med koden vår over er:\n\nÅrsvariabelen er en strengvariabel, fordi den fikk med seg bokstavene “aar” fra kolonnenavnet. Siden år er et tall (strengt tatt dato, men det er ikke viktig her), bør den være numerisk. Da kan vi seinere summere den opp lettere, samt at vi ikke trenger være redd for at sorteringa blir rar.\nJeg gjentar meg sjøl alt for mye i denne kodeblokken. Legg merke til at jeg skriver cols = c(aar2023, aar2024, aar2025). Her kunne jeg spart fingra mine en del, siden det er et repetativt mønster. Okei, kanskje ikke så mye innsparing her, men hvis vi hadde hatt tredve årskolonner ville det begynt å bety noe.\n\nVi løser nr 1. ved å ta i bruk noen nyttige funksjoner som tidyr-gjengen har lagt inn i pivot()-funksjonene. Og nr. 2 ved hjelp av tidyselect.\n\nprognose <- prognose %>% \n  pivot_longer(cols = contains(\"aar\"), \n               names_to = \"aar\", \n               values_to = \"befolkning\", \n               names_prefix = \"aar\",\n               names_transform = as.numeric)\n\nprognose\n\n# A tibble: 24 × 4\n   plansone kjonn   aar befolkning\n      <int> <chr> <dbl>      <dbl>\n 1  5001001 M      2023        541\n 2  5001001 M      2024        708\n 3  5001001 M      2025        412\n 4  5001001 K      2023        719\n 5  5001001 K      2024        662\n 6  5001001 K      2025        755\n 7  5001002 M      2023        458\n 8  5001002 M      2024        553\n 9  5001002 M      2025        791\n10  5001002 K      2023        441\n# … with 14 more rows\n\n\nHva gjorde vi her? Vi brukte contains() i utvelginga av kolonner for å treffe alle kolonner som inneholdt en viss tekststreng, her “aar”. Vi fikk fjerna tekststrengen “aar” fra kolonnas elementer ved å si fra til pivot_longer() at alle kolonnene vi valgte ut hadde dette prefikset. Til dette brukte vi names_prefix = \"aar\". Så gjorde vi om denne kolonna til numerisk ved å legge på en transformasjon via den enkle as.numeric()-funksjonen. Dette gjorde vi ved names_transform = as.numeric."
  },
  {
    "objectID": "pivot.html#fra-lang-til-vid",
    "href": "pivot.html#fra-lang-til-vid",
    "title": "7  Omstrukturering av data (pivot)",
    "section": "7.3 Fra lang til vid",
    "text": "7.3 Fra lang til vid\nSjøl om vi elsker tidy data hender det vi må besudle oss med vide, rotete data. For eksempel hvis vi har Excel-filer som forventer data på et visst format. Kanskje de vil ha år bortover. Så det er greit at vi veit åssen vi går fra lang til vid. Prosessen er stort sett bare det motsatte av hva vi gjorde med pivot_longer(), og det minner meg om dette sitatet fra Welcome to Nightvale:\n\nAnd now for a brief public service announcement: Alligators. Can they kill your children? Yes. Along those lines, to get personal for a moment, I think the best way to die would be: swallowed by a giant snake. Going feet first and whole into a slimy maw would give your life perfect symmetry.\n\n\nprognose %>% pivot_wider(names_from = aar,\n                         names_prefix = \"aar\",\n                         values_from = befolkning)\n\n# A tibble: 8 × 5\n  plansone kjonn aar2023 aar2024 aar2025\n     <int> <chr>   <dbl>   <dbl>   <dbl>\n1  5001001 M         541     708     412\n2  5001001 K         719     662     755\n3  5001002 M         458     553     791\n4  5001002 K         441     762     613\n5  5001003 M         518     667     428\n6  5001003 K         428     614     472\n7  5001004 M         555     467     776\n8  5001004 K         524     652     740"
  },
  {
    "objectID": "filter.html#filter",
    "href": "filter.html#filter",
    "title": "8  Velge rader",
    "section": "8.1 Filter",
    "text": "8.1 Filter\nFiltre bruker vi svært ofte. De lar oss begrense mengden data vi ser på og arbeider på. Vi får filtra våre dplyr. Merk at det finnes en filter-funksjon i stats-pakka som lastes inn når vi starer R, og dette filteret blir overskrevet av dplyr/tidyverse. Om du får feilmelding når du bruker filter kan det være at du har glemt å laste inn dplyr, og at R forsøker å bruke stats’ filter().\nFiltret velger ut rader ved å sjekke ut innholdet i en kolonne. Vi kan velge ut alle rader som har en viss verdi på en kolonne. La oss se på at alle menneskene i datasettet starwars.\n\nstarwars %>% filter(species == \"Human\")\n\n# A tibble: 35 × 14\n   name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵\n   <chr>        <int> <dbl> <chr>   <chr>   <chr>     <dbl> <chr> <chr>  <chr>  \n 1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…\n 2 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…\n 3 Leia Organa    150    49 brown   light   brown      19   fema… femin… Aldera…\n 4 Owen Lars      178   120 brown,… light   blue       52   male  mascu… Tatooi…\n 5 Beru White…    165    75 brown   light   blue       47   fema… femin… Tatooi…\n 6 Biggs Dark…    183    84 black   light   brown      24   male  mascu… Tatooi…\n 7 Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon\n 8 Anakin Sky…    188    84 blond   fair    blue       41.9 male  mascu… Tatooi…\n 9 Wilhuff Ta…    180    NA auburn… fair    blue       64   male  mascu… Eriadu \n10 Han Solo       180    80 brown   fair    brown      29   male  mascu… Corell…\n# … with 25 more rows, 4 more variables: species <chr>, films <list>,\n#   vehicles <list>, starships <list>, and abbreviated variable names\n#   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld\n\n\nFilteret velger alle radene hvor sammenlikninga vi oppgir er TRUE (sann). Mer robotisk kan vi si at den i tilfellet over velger rader hvor cella under kolonna species tilfredsstiller betingelsen “innholdet i cella er lik Human”. Dermed kan vi oppgi andre uttrykk som evalueres til enten TRUE eller FALSE. Hva med å hente ut alle som er høyere enn 170 cm?\n\nstarwars %>% filter(height > 170)\n\n# A tibble: 54 × 14\n   name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵\n   <chr>        <int> <dbl> <chr>   <chr>   <chr>     <dbl> <chr> <chr>  <chr>  \n 1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…\n 2 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…\n 3 Owen Lars      178   120 brown,… light   blue       52   male  mascu… Tatooi…\n 4 Biggs Dark…    183    84 black   light   brown      24   male  mascu… Tatooi…\n 5 Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon\n 6 Anakin Sky…    188    84 blond   fair    blue       41.9 male  mascu… Tatooi…\n 7 Wilhuff Ta…    180    NA auburn… fair    blue       64   male  mascu… Eriadu \n 8 Chewbacca      228   112 brown   unknown blue      200   male  mascu… Kashyy…\n 9 Han Solo       180    80 brown   fair    brown      29   male  mascu… Corell…\n10 Greedo         173    74 <NA>    green   black      44   male  mascu… Rodia  \n# … with 44 more rows, 4 more variables: species <chr>, films <list>,\n#   vehicles <list>, starships <list>, and abbreviated variable names\n#   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld\n\n\nVi kan oppgi flere betingelser. Hva med alle kvinnelige mennesker?\n\nstarwars %>% filter(species == \"Human\" & sex == \"female\")\n\n# A tibble: 9 × 14\n  name         height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵\n  <chr>         <int> <dbl> <chr>   <chr>   <chr>     <dbl> <chr> <chr>  <chr>  \n1 Leia Organa     150    49 brown   light   brown        19 fema… femin… Aldera…\n2 Beru Whites…    165    75 brown   light   blue         47 fema… femin… Tatooi…\n3 Mon Mothma      150    NA auburn  fair    blue         48 fema… femin… Chandr…\n4 Shmi Skywal…    163    NA black   fair    brown        72 fema… femin… Tatooi…\n5 Cordé           157    NA brown   light   brown        NA fema… femin… Naboo  \n6 Dormé           165    NA brown   light   brown        NA fema… femin… Naboo  \n7 Jocasta Nu      167    NA white   fair    blue         NA fema… femin… Corusc…\n8 Rey              NA    NA brown   light   hazel        NA fema… femin… <NA>   \n9 Padmé Amida…    165    45 brown   light   brown        46 fema… femin… Naboo  \n# … with 4 more variables: species <chr>, films <list>, vehicles <list>,\n#   starships <list>, and abbreviated variable names ¹​hair_color, ²​skin_color,\n#   ³​eye_color, ⁴​birth_year, ⁵​homeworld\n\n\nIkke så veldig mange. Ikke rart Star Wars filer Bechdel-testen. Får vi med flere hvis vi ikke skiller mellom sex og gender? Altså at vi tar med dem er enten female eller feminine?\n\nstarwars %>% filter(species == \"Human\" & (sex == \"female\" | gender == \"feminine\"))\n\n# A tibble: 9 × 14\n  name         height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵\n  <chr>         <int> <dbl> <chr>   <chr>   <chr>     <dbl> <chr> <chr>  <chr>  \n1 Leia Organa     150    49 brown   light   brown        19 fema… femin… Aldera…\n2 Beru Whites…    165    75 brown   light   blue         47 fema… femin… Tatooi…\n3 Mon Mothma      150    NA auburn  fair    blue         48 fema… femin… Chandr…\n4 Shmi Skywal…    163    NA black   fair    brown        72 fema… femin… Tatooi…\n5 Cordé           157    NA brown   light   brown        NA fema… femin… Naboo  \n6 Dormé           165    NA brown   light   brown        NA fema… femin… Naboo  \n7 Jocasta Nu      167    NA white   fair    blue         NA fema… femin… Corusc…\n8 Rey              NA    NA brown   light   hazel        NA fema… femin… <NA>   \n9 Padmé Amida…    165    45 brown   light   brown        46 fema… femin… Naboo  \n# … with 4 more variables: species <chr>, films <list>, vehicles <list>,\n#   starships <list>, and abbreviated variable names ¹​hair_color, ²​skin_color,\n#   ³​eye_color, ⁴​birth_year, ⁵​homeworld\n\n\nNei.\nMen vi fikk illustrert filteret. Vi bruker noen logiske operatorer for å kombinere ulike ledd i betingelsene våre.\n\n&: og. Både x og y må være tilfredsstilt.\n|: eller. Enten x eller y må være tilfredsstilt.\n==: er lik. x må være lik y.\n!=: er ikke lik. x må være ulik y.\n< og >: mindre enn og større enn\n<= og >=: mindre enn eller lik og større enn eller lik.\n\nOg vi bruker () for å gruppere betingelser sammen. La oss se på hva som skjer med antall rader som blir tatt med når vi fjerner ().\n\n# Med () rundt female og feminine\nstarwars %>% \n  filter(species == \"Human\" & (sex == \"female\" | gender == \"feminine\")) %>% \n  nrow()\n\n[1] 9\n\n# Uten ()\nstarwars %>% \n  filter(species == \"Human\" & sex == \"female\" | gender == \"feminine\") %>% \n  nrow()\n\n[1] 17\n\n\nI det første eksemplet må du være 1) menneske og 2) enten female eller feminine. I det andre eksemplet må du være 1) menneske og female eller 2) feminine. Dermed får vi med oss en del roboter og romvesener som er feminine i det andre eksemplet.\nVi bruker ofte filtre for å fjerne deler av et datasett, for eksempel dersom vi bare vil se på Trondheim. Da filtrer vi kanskje med ei kolonne som inneholder\n\nkommunnummeret til Trondheim (5001),\ndet gamle kommunenummeret til Trondheim (1601),\nen tekststreng med navet til byen (“Trondheim”),\nen tekststreng med det gamle navnet på byen (“Trondhjem”),\nen tekststreng med navnet på byen uten stor forbokstav (“Trondheim”), eller\nen tekststreng med navnet på byen feilstava (“Trodnheim”).\nen tekststreng med navnet på byen og noe tilleggstekst som vi ikke trenger (“Trondheim by”)\n\nAntakelig ikke alle på en gang, men det er greit å vite hvordan man gjør en delvis match. Spesielt når vi får en liste med navn på ting som må matches med våre egne data er det typisk at de skriver navna noe annerledes enn oss. Dette er gjerne fordi det ikke egentlig er noen standard måte å skrive navna på, eller fordi navna endres. Barnehagedatasett er et typisk eksempel her.\nÅ matche på ulike numre handler vanligvis om å sette sammen en serie med eller betingelser via |. Vi fokuserer derfor på tekststrenger. Til dette finner vi en svært nyttig pakke som heter stringr.\n\n\n\nPakka handler ikke om å selge dop i Baltimore, men om å håndtere tekststrenger."
  },
  {
    "objectID": "filter.html#stringr",
    "href": "filter.html#stringr",
    "title": "8  Velge rader",
    "section": "8.2 Stringr",
    "text": "8.2 Stringr\nstringr har drøssevis av nyttige funksjoner for oss, og vi har så klart ikke tid å gå innom alt. En del av funksjonene baserer seg på noe som kalles regulære uttrykk (regular expressions), ofte henvist til som regex. Regex er serier med tegn som spesifiserer et spesifikt mønster. Det brukes når vi vil ha treff på flere varianter.\nUnder bruker jeg regex for å treffe på to skrivemåter av Trondheim. Vi bruker str_detect() for å detektere strenger i en kolonne som matcher et mønster. Mønsteret er altså Trondheim eller Trondhjem. Siden den eneste forskjellen på disse to er om vi bruker ei eller je i slutten, kan vi skrive dette som \"Trondh(ei|je)m\".\n\n# Lager et fiktivt lite datasett\nbyer <- tibble(\n  by = c(\"Trondheim\", \"Trondhjem\", \"Drammen\"),\n  valuta = c(\"NOK\", \"riksdaler\", \"NOK\")\n)\n\n# Filter ved hjelp av regex\nbyer %>% \n  filter(str_detect(by, \"Trondh(ei|je)m\"))\n\n# A tibble: 2 × 2\n  by        valuta   \n  <chr>     <chr>    \n1 Trondheim NOK      \n2 Trondhjem riksdaler\n\n# En mindre effektiv måte å gjøre dette på ville vært\nbyer %>% \n  filter(by == \"Trondheim\" | by == \"Trondhjem\")\n\n# A tibble: 2 × 2\n  by        valuta   \n  <chr>     <chr>    \n1 Trondheim NOK      \n2 Trondhjem riksdaler\n\n\nDu kan spørre deg hvorfor det andre eksemplet er mindre effektivt når det bare koster oss noen få ekstra tegn. Fordi jeg må gjenta meg sjøl når jeg skriver by == og Trondh. Akkurat i dette tilfellet er det ikke særlig alvorlig. Men når vi utvider og får større datasett og mer avanserte søkemønstre vil det begynne å gjøre seg gjeldende. En ting er at vi sparer tid på skrive mindre. En annen ting er at det blir lettere å gjøre endringer seinere. Fordi vi ikke må endre en serie med eller-betingelser, men kun den ene regex-en.\nAlle funksjonene i stringr starter med str_, som gjør dem lett å søke opp. Nyttig, for det er mange av dem! De jeg bruker oftest er\n\nstr_sub() for å hente ut en del av en streng\nstr_detect() i kombinasjon med filter() for å finne en delvis match i en kolonne\nstr_replace() for å erstatte del av en streng med noe annet\nstr_to_lower() og str_to_upper() for å fjerne feilkilder når jeg søker. Spesielt den første er nyttig. Hvis jeg skal matche på navn vil jeg unngå at jeg får ikke-match bare fordi noen navn har store bokstaver enkelte steder mens andre ikke. Jeg vil at “Byåsen barnehage” skal matche med Byåsen Barnehage. Merk at det finnes varianter av disse i base R også.\n\nLa oss se noen eksempler på bruk av disse\n\n# Hent ut de fire første bokstavene av en kolonne\nbyer %>% \n  mutate(by4 = str_sub(by, 1, 4))\n\n# A tibble: 3 × 3\n  by        valuta    by4  \n  <chr>     <chr>     <chr>\n1 Trondheim NOK       Tron \n2 Trondhjem riksdaler Tron \n3 Drammen   NOK       Dram \n\n# Bytt ut deler av en streng\nbyer %>% \n  mutate(nytt_bynavn = str_replace(by, \"Trond\", \"Trønder\"))\n\n# A tibble: 3 × 3\n  by        valuta    nytt_bynavn\n  <chr>     <chr>     <chr>      \n1 Trondheim NOK       Trønderheim\n2 Trondhjem riksdaler Trønderhjem\n3 Drammen   NOK       Drammen    \n\n# Gjøre om en kolonne til små bokstaver. \nbyer %>% \n  mutate(valuta_lower = str_to_lower(valuta))\n\n# A tibble: 3 × 3\n  by        valuta    valuta_lower\n  <chr>     <chr>     <chr>       \n1 Trondheim NOK       nok         \n2 Trondhjem riksdaler riksdaler   \n3 Drammen   NOK       nok         \n\n\nstringr har mange muligheter i seg. Spesielt bruken av regex er svært nyttig, som nevnt over. Men læringskurva er bratt. Og særlig det å søke etter tall i en tekststreng. Noen nyttige funksjoner her er å kombinere tegntype og kvantitet. Sjekk ut side to av stringr-jukselappen til Posit.\nHer lager jeg et rart datasett for å vise hvordan vi kan bruke disse regex-kommandoene. Datasettet blir laga ved å sette sammen tilfeldige serier med tall og bokstaver som vi seinere kan søke på. Her bruker jeg set.seed() for å sørge for at de påfølgende randomiserte prosessene blir like hver gang de kjøres. Slik at du og jeg ser de samme talla hver gang.\n\nset.seed(123)\n\n# En funksjon som lager en serie av siffer og bokstaver av ulik lengde.\nlag_streng <- function() {\n  tall <- seq(1:10) %>% as.character()\n  bokstaver <- letters[1:10]\n  tall_bokstaver <- c(tall, bokstaver)\n  \n  paste0(sample(tall_bokstaver, size = runif(1, 3, 5), replace = TRUE), collapse = \"\")\n}\n\nset.seed(123)\n\n# Setter det sammen i et datasett.  \nutvalg <- tibble(\n  id = seq(1:200), \n  name = replicate(200, lag_streng())\n)\n\n# Slik ser det ut. \nutvalg\n\n# A tibble: 200 × 2\n      id name \n   <int> <chr>\n 1     1 eid  \n 2     2 10ha5\n 3     3 d5i9 \n 4     4 38710\n 5     5 i4dg \n 6     6 7be10\n 7     7 799  \n 8     8 762  \n 9     9 58b  \n10    10 ch1  \n# … with 190 more rows\n\n# La oss finne de navna hvor det er to bokstaver etterfulgt av to nummer\nutvalg %>% \n  filter(str_detect(name, \"[[:alpha:]]{2}[[:digit:]]{2}\"))\n\n# A tibble: 12 × 2\n      id name  \n   <int> <chr> \n 1     6 7be10 \n 2    16 jd38  \n 3    32 bg10  \n 4    43 dd61  \n 5    49 ch106 \n 6    52 hg12  \n 7    56 ff34  \n 8    77 bc1010\n 9    97 2fi10 \n10   155 hhj10 \n11   162 af54  \n12   189 cd29  \n\n\nDette mønstret ser overveldende ut, så la oss pakke det ut: \"[[:alpha:]]{2}[[:digit:]]{2}\"\n\n[[:alpha:]] treffer alle bokstaver.\n[[:digit:]] treffer alle tall.\n{2} betyr nøyaktig to forekomster av det som kom før meg. Vi bruker den både for bokstaver og tall. Alternativet ville vært å skrevet f.eks. [[:alpha:]][[:alpha:]]\n\n\nDet er verdt å tenke litt på tegnkoding igjen. Hvordan lagres informasjon om tall og bokstaver på pc-en? Hvordan behandles tall og bokstaver (og symboler) annerledes av programmeringsspråk som R? En tallserie vil f.eks. sorteres annerledes avhengig av om den er koda som numerisk eller streng.\n\n# En vektor som inneholder en serie fra 1 til 24 i tilfeldig rekkefølge\ntall <- sample(c(1:24), 24)\n\n# Vi sortere den først når den er numerisk og deretter når den er en streng.\ntall %>% sort()\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n\ntall %>% as.character() %>% sort()\n\n [1] \"1\"  \"10\" \"11\" \"12\" \"13\" \"14\" \"15\" \"16\" \"17\" \"18\" \"19\" \"2\"  \"20\" \"21\" \"22\"\n[16] \"23\" \"24\" \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\" \n\n\nI neste kodeblokk lager jeg to datasett. Det første er likt det vi hadde i sted, foruten at jeg kun henter ut de første ti radene. Det andre datasettet er likt dette, foruten at jeg har bedt om kun ett siffer (digit) på slutten. For å vise tydeligere hva som skjer binder jeg de to radene sammen.\n\nfoo <- utvalg %>% \n  filter(str_detect(name, \"[[:alpha:]]{2}[[:digit:]]{2}\")) %>% \n  slice(1:10)\n\nbar <- utvalg %>% \n  filter(str_detect(name, \"[[:alpha:]]{2}[[:digit:]]{1}\")) %>% \n  slice(1:10)\n\nbind_cols(foo, bar)\n\nNew names:\n• `id` -> `id...1`\n• `name` -> `name...2`\n• `id` -> `id...3`\n• `name` -> `name...4`\n\n\n# A tibble: 10 × 4\n   id...1 name...2 id...3 name...4\n    <int> <chr>     <int> <chr>   \n 1      6 7be10         2 10ha5   \n 2     16 jd38          6 7be10   \n 3     32 bg10         10 ch1     \n 4     43 dd61         12 fj6     \n 5     49 ch106        14 hg2     \n 6     52 hg12         16 jd38    \n 7     56 ff34         17 bd3d    \n 8     77 bc1010       21 gd3     \n 9     97 2fi10        23 ga7     \n10    155 hhj10        26 fa4b    \n\n\nLegg merke til kolonna helt til høyre. Vi ba om kun ett siffer, likevel får vi “7be10” og “jd38”. Hvorfor? Fordi de inneholder, nettopp “ett siffer”. Dette sifferet er tilfeldigvis etterfulgt av et annet siffer, men det sa vi ikke spesifikt at vi skulle unngå. Her gjorde jeg en antakelse som viste seg å ikke stemme. Det var en antakelse jeg ikke var helt bevisst at jeg gjorde, og det var at koden min skulle vise meg rader som inneholder to bokstaver og ett, og kun ett, ikke to eller flere, siffer.\nVi ser det samme skjer med den første kolonna også: her får vi treff på to bokstaver etterfulgt av tre og fire siffer. Hvis vi skulle fiksa koden til å treffe på “to bokstaver etterfulgt av kun to og ikke flere siffer” kunne vi endra det slik:\n\nutvalg %>% \n  filter(str_detect(name, \"[[:alpha:]]{2}[[:digit:]]{2}(?![[:digit:]])\"))\n\n# A tibble: 10 × 2\n      id name \n   <int> <chr>\n 1     6 7be10\n 2    16 jd38 \n 3    32 bg10 \n 4    43 dd61 \n 5    52 hg12 \n 6    56 ff34 \n 7    97 2fi10\n 8   155 hhj10\n 9   162 af54 \n10   189 cd29 \n\n\nDet jeg håper på å få fram her er at vi må stoppe opp innimellom og teste våre egne antakelser og arbeid."
  },
  {
    "objectID": "filter.html#select",
    "href": "filter.html#select",
    "title": "8  Velge rader",
    "section": "8.3 Select",
    "text": "8.3 Select\nVi har brukt select() før, se Section 6.3.1. Den er nyttig å ta opp igjen her. Med select() kan vi velge ut kolonner og med filter() kan vi velge ut rader. Dermed er det ofte nyttig å bruke begge sammen. Jeg bruker dem spesielt mye når jeg gjør en første gjennomgang av et skript. Da velger jeg ut kun de radene og kolonnene som jeg er interessert i og arbeider på dem. Dette gjør det lettere å se om koden min funker, uten å måtte se for mye urelevant. Når jeg veit at skriptet funker, kan jeg gå tilbake og fjerne select() og filter() slik at hele datasettet kjøres gjennom skriptet.\nDet er nyttig å vite at vi kan bruke noen liknende streng-teknikker på select() som vi brukte på filter(). Vi henter inn et nytt, simulert datasett hvor den del av kolonnene våre har navn på samme form.\n\nprognose <- tibble(\n  plansone = rep(seq(5001001, 5001004), each = 2),\n  kjonn = rep(c(\"M\", \"K\"), 4),\n  aar2023 = round(runif(8, 400, 800)),\n  aar2024 = round(runif(8, 400, 800)),\n  aar2025 = round(runif(8, 400, 800))\n) %>% \n  tibble(\n    faktisk2023 = round(aar2023 + aar2023 * (rnorm(1, 0, 10)/100)),\n    faktisk2024 = round(aar2024 + aar2024 * (rnorm(1, 0, 10)/100)),\n    faktisk2025 = round(aar2025 + aar2025 * (rnorm(1, 0, 10)/100))\n  )\nprognose\n\n# A tibble: 8 × 8\n  plansone kjonn aar2023 aar2024 aar2025 faktisk2023 faktisk2024 faktisk2025\n     <int> <chr>   <dbl>   <dbl>   <dbl>       <dbl>       <dbl>       <dbl>\n1  5001001 M         460     550     753         453         545         785\n2  5001001 K         472     781     475         464         773         495\n3  5001002 M         536     408     486         527         404         506\n4  5001002 K         474     645     748         466         639         779\n5  5001003 M         562     585     424         553         579         442\n6  5001003 K         645     542     494         635         537         515\n7  5001004 M         674     753     797         663         746         831\n8  5001004 K         729     430     671         717         426         699\n\n\nHer har vi kun tre av hver kolonne, men se for dere at vi hadde hatt tredve. Da ville det vært nyttig å slippe å skrive inn navnet på hver enkelt.\nLa oss si at vi vil ha tak i kun de faktiske befolkningstalla, altså de kolonnene som har “faktisk” i navnet. Vi kan bruke contains() eller matches() inni select().\n\nprognose %>% \n  select(contains(\"faktisk\"))\n\n# A tibble: 8 × 3\n  faktisk2023 faktisk2024 faktisk2025\n        <dbl>       <dbl>       <dbl>\n1         453         545         785\n2         464         773         495\n3         527         404         506\n4         466         639         779\n5         553         579         442\n6         635         537         515\n7         663         746         831\n8         717         426         699\n\n\nHva er forskjellen på dem? matches() lar oss bruke en regex. Si at vi vil ha kolonner med “faktisk” i navnet, etterfulgt av en eller flere siffer, og som slutter på 5.\n\nprognose %>% \n  select(matches(\"faktisk[[:digit:]]+5$\"))\n\n# A tibble: 8 × 1\n  faktisk2025\n        <dbl>\n1         785\n2         495\n3         506\n4         779\n5         442\n6         515\n7         831\n8         699\n\n\nJeg bruker ofte select() til å endre rekkefølgen på kolonner. Ofte vil jeg ha den kolonna jeg nettopp lagde fremst. Da er det nyttig å huske på noen av triksa fra tidy evaluation: everything(). Den lar meg slippe å skrive opp alle kolonnene i datasettet:\n\nprognose %>% \n  select(plansone, faktisk2025, everything())\n\n# A tibble: 8 × 8\n  plansone faktisk2025 kjonn aar2023 aar2024 aar2025 faktisk2023 faktisk2024\n     <int>       <dbl> <chr>   <dbl>   <dbl>   <dbl>       <dbl>       <dbl>\n1  5001001         785 M         460     550     753         453         545\n2  5001001         495 K         472     781     475         464         773\n3  5001002         506 M         536     408     486         527         404\n4  5001002         779 K         474     645     748         466         639\n5  5001003         442 M         562     585     424         553         579\n6  5001003         515 K         645     542     494         635         537\n7  5001004         831 M         674     753     797         663         746\n8  5001004         699 K         729     430     671         717         426"
  },
  {
    "objectID": "transformasjoner.html#mutate",
    "href": "transformasjoner.html#mutate",
    "title": "9  Tranformasjoner",
    "section": "9.1 Mutate",
    "text": "9.1 Mutate\nmutate() kommer fra etc. etc. You know the drill. Den en enkel å bruke. Hvis vi vil lage en ny kolonne bare gir vi den et navn og definerer hvordan den skal se ut. Vi tar inn prognoseeksemplet vårt:\n\nprognose <- tibble(\n  plansone = rep(seq(5001001, 5001004), each = 2),\n  kjonn = rep(c(\"M\", \"K\"), 4),\n  aar2023 = round(runif(8, 400, 800)),\n  aar2024 = round(runif(8, 400, 800)),\n  aar2025 = round(runif(8, 400, 800))\n) %>% \n  rowwise() %>% \n  tibble(\n    faktisk2023 = round(aar2023 + aar2023 * (rnorm(1, 0, 10)/100)),\n    faktisk2024 = round(aar2024 + aar2024 * (rnorm(1, 0, 10)/100)),\n    faktisk2025 = round(aar2025 + aar2025 * (rnorm(1, 0, 10)/100))\n  )\nprognose\n\n# A tibble: 8 × 8\n  plansone kjonn aar2023 aar2024 aar2025 faktisk2023 faktisk2024 faktisk2025\n     <int> <chr>   <dbl>   <dbl>   <dbl>       <dbl>       <dbl>       <dbl>\n1  5001001 M         722     796     530         754         868         510\n2  5001001 K         442     590     598         462         643         575\n3  5001002 M         596     463     739         622         505         711\n4  5001002 K         695     418     690         726         456         664\n5  5001003 M         479     624     631         500         680         607\n6  5001003 K         683     449     787         713         490         757\n7  5001004 M         766     726     796         800         792         766\n8  5001004 K         532     495     696         555         540         670\n\n\nSi at vi vil vite differansen mellom prognosen (“aarXXXX”) og faktisk befolkning (“faktiskXXXX”).\n\nprognose %>% \n  mutate(diff2023 = aar2023 - faktisk2023,\n         diff2024 = aar2024 - faktisk2024,\n         diff2025 = aar2025 - faktisk2025)\n\n# A tibble: 8 × 11\n  plansone kjonn aar2023 aar2024 aar2025 fakti…¹ fakti…² fakti…³ diff2…⁴ diff2…⁵\n     <int> <chr>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n1  5001001 M         722     796     530     754     868     510     -32     -72\n2  5001001 K         442     590     598     462     643     575     -20     -53\n3  5001002 M         596     463     739     622     505     711     -26     -42\n4  5001002 K         695     418     690     726     456     664     -31     -38\n5  5001003 M         479     624     631     500     680     607     -21     -56\n6  5001003 K         683     449     787     713     490     757     -30     -41\n7  5001004 M         766     726     796     800     792     766     -34     -66\n8  5001004 K         532     495     696     555     540     670     -23     -45\n# … with 1 more variable: diff2025 <dbl>, and abbreviated variable names\n#   ¹​faktisk2023, ²​faktisk2024, ³​faktisk2025, ⁴​diff2023, ⁵​diff2024\n\n\nDersom vi vil oppdatere verdien til en kolonne kan vi overskrive den i mutate ved å gi den nye variabelen samme navn som en eksisterende variabel.\n\n# Vi oppdaterer prognosen for 2025 fordi vi forventer dobbelt så mange som vi \n# opprinnelig hadde tenkt.\nprognose %>% \n  mutate(aar2025 = aar2025 * 2)\n\n# A tibble: 8 × 8\n  plansone kjonn aar2023 aar2024 aar2025 faktisk2023 faktisk2024 faktisk2025\n     <int> <chr>   <dbl>   <dbl>   <dbl>       <dbl>       <dbl>       <dbl>\n1  5001001 M         722     796    1060         754         868         510\n2  5001001 K         442     590    1196         462         643         575\n3  5001002 M         596     463    1478         622         505         711\n4  5001002 K         695     418    1380         726         456         664\n5  5001003 M         479     624    1262         500         680         607\n6  5001003 K         683     449    1574         713         490         757\n7  5001004 M         766     726    1592         800         792         766\n8  5001004 K         532     495    1392         555         540         670\n\n\n\n9.1.1 Noen nyttige funksjoner til mutate\nHer er noen nyttige funksjoner som jeg ofte bruker sammen med mutate().\nVarianter av if else: ifelse(), if_else og case_when.\n\n# Vi lager et datasett med noen personer som vi veit kjønn og alder til.\nset.seed(123)\nfolk <- tibble(\n  kjonn = rep(c(\"M\", \"K\"), 25),\n  alder = round(runif(50, 10, 80))\n)\nfolk\n\n# A tibble: 50 × 2\n   kjonn alder\n   <chr> <dbl>\n 1 M        30\n 2 K        65\n 3 M        39\n 4 K        72\n 5 M        76\n 6 K        13\n 7 M        47\n 8 K        72\n 9 M        49\n10 K        42\n# … with 40 more rows\n\n# Vi kan lage en ny variabel som forteller oss hvem som er myndig (fylt 18):\n# Til dette bruker vi `if_else()`. \nfolk %>% \n  mutate(myndig = if_else(alder > 17, TRUE, FALSE))\n\n# A tibble: 50 × 3\n   kjonn alder myndig\n   <chr> <dbl> <lgl> \n 1 M        30 TRUE  \n 2 K        65 TRUE  \n 3 M        39 TRUE  \n 4 K        72 TRUE  \n 5 M        76 TRUE  \n 6 K        13 FALSE \n 7 M        47 TRUE  \n 8 K        72 TRUE  \n 9 M        49 TRUE  \n10 K        42 TRUE  \n# … with 40 more rows\n\n# Verdiene til `if_else()` kan være noe annet også:\nfolk %>% \n  mutate(myndig = if_else(alder > 17, \"myndig\", \"barn\"))\n\n# A tibble: 50 × 3\n   kjonn alder myndig\n   <chr> <dbl> <chr> \n 1 M        30 myndig\n 2 K        65 myndig\n 3 M        39 myndig\n 4 K        72 myndig\n 5 M        76 myndig\n 6 K        13 barn  \n 7 M        47 myndig\n 8 K        72 myndig\n 9 M        49 myndig\n10 K        42 myndig\n# … with 40 more rows\n\n\nHva er forskjellen på ifelse() og if_else()? Sistnevnte kommer fra dplyr og er en kjappere og strengere versjon av ifelse(). Alle argumenta må være av samme type, så du henter du får feilmelding når du bruker denne.\ncase_when() er en nyttig utvidelse av if else-tankegangen når vi har mer enn to muligheter. For eksempel hvis vi skal lage en kjapp alderskategorisering. case_when() følger en struktur hvor du definerer betingelsen på venstre side av ~ og resultatet på høyre side. Bruken av tilde (~) indikerer at dette et et formel-objekt. Vi har ikke snakka noe særlig om formel-objekter hittil, og jeg tenker at vi ikke trenger å gå inn på det her heller. Men hvis du noen gang skal gjøre noe fancy med case_when() kan det være greit å vite at den bruker formler i koden sin.\n\nfolk %>% \n  mutate(alders_gruppe = case_when(\n    alder < 18 ~ 1, \n    alder >= 18 & alder < 30 ~ 2,\n    alder >= 30 & alder < 40 ~ 3,\n    alder >= 40 & alder < 50 ~ 4,\n    alder > 50 ~ 5,\n    TRUE ~ NA_real_)\n  )\n\n# A tibble: 50 × 3\n   kjonn alder alders_gruppe\n   <chr> <dbl>         <dbl>\n 1 M        30             3\n 2 K        65             5\n 3 M        39             3\n 4 K        72             5\n 5 M        76             5\n 6 K        13             1\n 7 M        47             4\n 8 K        72             5\n 9 M        49             4\n10 K        42             4\n# … with 40 more rows\n\n\nNoen ting å merke seg med case_when():\n\nLogikken arbeider seg nedover og for hver rad velger den ut den første betingelsen som stemmer.\nDet er smart å ha en catch-all på slutten av case_when(). Du ser det i eksemplet mitt over, i form av det siste argumentet som er TRUE ~ NA_real_. Dersom ingen av betingelsene over stemmer, vil raden få verdien NA. Hvorfor skriver jeg NA_real_? case_when(), lik if_else() er streng med å holde seg til samme type verdier. Derfor lar den meg ikke uten videre bruke NA uten å definere om dette er en numerisk NA eller en streng-NA. Hadde jeg brukt strenger som gruppenavn istedenfor tall ville jeg i siste linje oppgitt NA_character_ istedenfor.\nDersom du arbeider på en case_when() som begynner å bli lang og komplisert er det ofte bedre å heller gjøre det om til en funksjon."
  },
  {
    "objectID": "transformasjoner.html#transmute",
    "href": "transformasjoner.html#transmute",
    "title": "9  Tranformasjoner",
    "section": "9.2 Transmute",
    "text": "9.2 Transmute\nTvillingen til mutate() heter transmute(). De opererer likt, bortsett fra at transmute() kun beholder de variabelene som blir laga. Noen ganger er dette nyttig. Merk at det gjør disse to kodebrokkene lik\n\n# Dette\nprognose %>% \n  mutate(aar2025 = aar2025 * 2) %>% \n  select(aar2025)\n\n# A tibble: 8 × 1\n  aar2025\n    <dbl>\n1    1060\n2    1196\n3    1478\n4    1380\n5    1262\n6    1574\n7    1592\n8    1392\n\n# Er det samme som dette\nprognose %>% \n  transmute(aar2025 = aar2025 * 2)\n\n# A tibble: 8 × 1\n  aar2025\n    <dbl>\n1    1060\n2    1196\n3    1478\n4    1380\n5    1262\n6    1574\n7    1592\n8    1392"
  },
  {
    "objectID": "transformasjoner.html#summarise",
    "href": "transformasjoner.html#summarise",
    "title": "9  Tranformasjoner",
    "section": "9.3 Summarise",
    "text": "9.3 Summarise\nOgså nært beslekta er summarise(). Vi har prata om summarise() tidligere (Section 6.4), og du vil lett se at disse likner på hverandre. summarise() bruker vi når vi vil lage en oversikt over enkelte deler av, eller hele, datasettet. Til forskjell fra mutate() summerer den opp alle radene på hver kolonne, eventuelt gruppert etter grupper om man kombinerer den med group_by()."
  },
  {
    "objectID": "joins.html#kompliserende-faktorer",
    "href": "joins.html#kompliserende-faktorer",
    "title": "10  Sammenslåing av data",
    "section": "10.1 Kompliserende faktorer",
    "text": "10.1 Kompliserende faktorer\nDet er ikke alltid like enkelt å slå sammen datasett.\n\n10.1.1 En til mange\nNoen ganger har vi en en-til-mange sammenslåing. I dette eksemplet har datX en kolonne colA med bokstaver fra a til d. De forekommer bare en gang hver. Når vi slår den sammen med datY, hvor det er tre rader per bokstav i colA, blir det sammenslåtte datasettet å brette ut colA slik vi at får med oss alle verdiene i datY hvor colA har like elementer i begge datasetta.\n\n# Genererer to datasett fulle av tall og bokstaver.\ndatX <- tibble(\n  colA = letters[1:5],\n  colB = seq(1:5)\n)\n\ndatY <- tibble(\n  colA = rep(letters[1:10], each = 3), \n  colC = c(10:39)\n)\n\ndatX \n\n# A tibble: 5 × 2\n  colA   colB\n  <chr> <int>\n1 a         1\n2 b         2\n3 c         3\n4 d         4\n5 e         5\n\ndatY\n\n# A tibble: 30 × 2\n   colA   colC\n   <chr> <int>\n 1 a        10\n 2 a        11\n 3 a        12\n 4 b        13\n 5 b        14\n 6 b        15\n 7 c        16\n 8 c        17\n 9 c        18\n10 d        19\n# … with 20 more rows\n\n# Slår dem sammen via colA.\ndatX %>% left_join(datY, by = \"colA\")\n\n# A tibble: 15 × 3\n   colA   colB  colC\n   <chr> <int> <int>\n 1 a         1    10\n 2 a         1    11\n 3 a         1    12\n 4 b         2    13\n 5 b         2    14\n 6 b         2    15\n 7 c         3    16\n 8 c         3    17\n 9 c         3    18\n10 d         4    19\n11 d         4    20\n12 d         4    21\n13 e         5    22\n14 e         5    23\n15 e         5    24\n\n\nDet observante leser kan observere at vi i dette tilfellet kunne tatt sammenslåinga motsatt vei ved å enten bruke en right_join() eller sette datyY som x og vice versa. Da ville vi lagt på datY sine verdier på datX istedenfor motsatt, og vi ville ikke tenkt å tenke på utbrettinga av datX. Noen ganger er det likevel denne veien vi vil gå, f.eks. hvis vi virkelig bare er interessert i observasjoner fra x. Her, f.eks., tar vi ikke med alle bokstavene som forekommer i y. Hadde vi valgt å slå sammen y på x ville vi måtte fjerne disse manuelt seinere. Og det kunne vi fint gjort. Igjen, det er mange veier til Rom.\n\n\n10.1.2 Partial match\nDet er ofte enklest å slå sammen basert på et tall, som ID. Dette fordi vi i større grad forventer at ID-er er 1) unike og 2) konsekvente på tvers av datasetta. Men noen ganger ender vi opp med å matche basert på navn. For eksempel når vi har ei liste med barnehagenavn som vi vil bruke til å matche informasjon fra to ulike tabeller. En utfordring som fort oppstår da er at navna ikke er 100 % identisk i de to datasetta. Eksempelvis vil noen skrive barnehagenavnet med “barnehage” i navnet, noen skriver barnehage med stor B, andre med liten, noen feilstaver kanskje barnehagenavnet, eller kanskje barnehagen har endra navn siden det ene datasettet blei oppretta. Det er mange grunner til inkonsekvens. Resultatet er det samme: vi må håndtere det på et vis.\nTo ulike tilnærminger kan brukes:\n\nendre ett eller begge datasetta programmatisk slik at de blir likere hverandre. Kanskje vi finner ut at “barnehage” ikke er nyttig i et barnehagenavn, så vi fjerner alle forekomster av det.\nfuzzy join: ta ibruk funksjoner som lar oss slå sammen datasett basert på ueksakte matcher. En slik pakke er fuzzy_join().\n\n(Lista er ikke uttømmende. Det er så klart mange andre mulige måter å gjøre dette på.)\nBegge tilnærmingene involverer å bruke regex. I arbeidet med barnehagekapasitet har jeg brukt slike matcher en del. Der gikk jeg for tilnærming 1. Det er klare rom for forbedring her, og jeg tror det ville involvert mer regex."
  },
  {
    "objectID": "joins.html#den-allsidige-join",
    "href": "joins.html#den-allsidige-join",
    "title": "10  Sammenslåing av data",
    "section": "10.2 Den allsidige join",
    "text": "10.2 Den allsidige join\nHovedpoenget med joins er å slå sammen datasett fra ulike kilder. I min kode vil dere se at jeg innimellom har funnet andre bruksområder for dem. I enkelte tilfeller finnes det sikkert andre måter å løse problemet på, men den første løsninga jeg fant som virka, var å bruke join. Og hvis det funker, er det greit. La oss se et eksempel: Vi har et datasett som viser antall personer i hver alder (fra 0 til 119). Vi har lyst å gjøre om kontinuerlig alder til alderskategorier med fem alderstrinn i hver kategori opp til 80. Alle som er 80 eller eldre havner i sin egen kategori. Vi kan gjøre dette enkelt med en mutate() og case_when(), men det vil kreve at vi gjentar oss sjøl mer enn tre ganger. Ergo kan vi spare tid ved å gjøre det per programmatisk.1\n\n# Simulerer folkemengden i et område, i form av antall personer av hver \n# kjønn og hvert alderstrinn.\nfolkemengde <- tibble(\n  alder = c(c(0:119), c(0:119)),\n  kjonn = c(rep(\"M\", 120), rep(\"K\", 120)),\n  antall = round(runif(240, 50, 200))\n)\nfolkemengde\n\n# A tibble: 240 × 3\n   alder kjonn antall\n   <int> <chr>  <dbl>\n 1     0 M         93\n 2     1 M         76\n 3     2 M         76\n 4     3 M        122\n 5     4 M         88\n 6     5 M         82\n 7     6 M        151\n 8     7 M         57\n 9     8 M        155\n10     9 M        103\n# … with 230 more rows\n\n\nHer er den suboptimale løsninga\n\nfolkemengde %>% \n  mutate(\n    aldersgruppe = case_when(\n      alder < 5 ~ 1, \n      alder >= 5 & alder < 10 ~ 2,\n      alder >= 10 & alder < 15 ~ 3,\n      # ... osv.\n      TRUE ~ NA_real_\n    )\n  )\n\n# A tibble: 240 × 4\n   alder kjonn antall aldersgruppe\n   <int> <chr>  <dbl>        <dbl>\n 1     0 M         93            1\n 2     1 M         76            1\n 3     2 M         76            1\n 4     3 M        122            1\n 5     4 M         88            1\n 6     5 M         82            2\n 7     6 M        151            2\n 8     7 M         57            2\n 9     8 M        155            2\n10     9 M        103            2\n# … with 230 more rows\n\n\nOg vår smarte løsning som utnytter en join. Vi starter med å lage aldersgruppene via serier med tall. Dette kan vi gjøre fordi de første 16 aldersgruppene er like store, de inneholder fem alderstrinn hver. Vi bruker rep() sammen med seq() for å repetere hvert ledd i en sekvens fem ganger. Vi legger disse aldersgruppene inn i et datasett ved siden av kontinuerlig alder. Nå har vi et datasett som vi rett og slett kan slå sammen med vår opprinnelig datasett. Nøkkelen blir alder.\n\n# Legg på alderskategorier ----\n# Vi lager alderskategorier. Deler inn alle aldre i grupper med fem alderstrinn\n# i hver. Dette gjør vi ved å fordele hver alder i en kategori, og lime disse\n# kategoriene inn i datasettet vårt.\n\n# Lager en serie fra 0 til 119.\nalder <- c(0:119)\n\n# Lager en serie fra 17 hvor hver kategori repeteres fem ganger. Siste kategori\n# repeteres til slutten (alle mellom 80 og 119).\naldersgruppe <- rep(seq(1:16), each = 5) %>% \n  c(rep(17, 40))\n\n# Putter de to seriene inn i et data.frame slik at vi kan bruke den seinere.\nalder_df <- tibble(\n  alder = alder,\n  aldersgruppe = aldersgruppe\n)\n\n# Logikken er at vi merger folkemengde med aldersdatasettet for å få \n# overført alderskategoriene våre.\nfolkemengde <- folkemengde %>% \n  left_join(alder_df, \n            by = \"alder\")\nfolkemengde\n\n# A tibble: 240 × 4\n   alder kjonn antall aldersgruppe\n   <int> <chr>  <dbl>        <dbl>\n 1     0 M         93            1\n 2     1 M         76            1\n 3     2 M         76            1\n 4     3 M        122            1\n 5     4 M         88            1\n 6     5 M         82            2\n 7     6 M        151            2\n 8     7 M         57            2\n 9     8 M        155            2\n10     9 M        103            2\n# … with 230 more rows\n\n# Vi kan summere opp  for å vise at vi fikk det til.\nfolkemengde %>% \n  group_by(kjonn, aldersgruppe) %>% \n  summarise(antall = sum(antall)) %>% \n  print(n = 25)\n\n`summarise()` has grouped output by 'kjonn'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 34 × 3\n# Groups:   kjonn [2]\n   kjonn aldersgruppe antall\n   <chr>        <dbl>  <dbl>\n 1 K                1    579\n 2 K                2    712\n 3 K                3    670\n 4 K                4    640\n 5 K                5    600\n 6 K                6    692\n 7 K                7    538\n 8 K                8    632\n 9 K                9    500\n10 K               10    789\n11 K               11    675\n12 K               12    667\n13 K               13    529\n14 K               14    570\n15 K               15    601\n16 K               16    704\n17 K               17   4878\n18 M                1    455\n19 M                2    548\n20 M                3    758\n21 M                4    601\n22 M                5    733\n23 M                6    469\n24 M                7    700\n25 M                8    587\n# … with 9 more rows\n\n\nDet finnes helt sikkert enda enklere løsninger enn dette, og litt av gleden av å jobbe i R er å oppdage disse og forbedre gamle syntakser."
  },
  {
    "objectID": "arbeidsprosess.html#rproj",
    "href": "arbeidsprosess.html#rproj",
    "title": "11  Arbeidsprosess",
    "section": "11.1 Rproj",
    "text": "11.1 Rproj\nRstudio-prosjekter er en nyttig måte å organisere prosjekter i R. Hovednytten kommer i at alle filstier blir relative til prosjektets rotmappe. Rotmappa er der .Rproj-fila ligger. Hadde jeg måtte definere alle stier ut fra hvor de ligger på min PC ville det blitt vanskelgiere for dere å ta over. Pakka here er også nyttig for å gjøre stier enda mer robuste.\nNår vi prater om .Rproj, her er en instilling dere burde endre på hvis du ikke alt har gjort det: Skru av lagring av workspace mellom sesjoner. Se beskrivelse i Section 4.1.\nHvis du lurer på om en mappe er et Rstudio-prosjekt kan se se etter en .Rproj-fil. Legg f.eks. merke til at i mappa apps inneholder tre undermapper og ingen .Rproj. Dette fordi hver app er sitt eget Rstudio-prosjekt."
  },
  {
    "objectID": "arbeidsprosess.html#main-filer-og-mappestruktur",
    "href": "arbeidsprosess.html#main-filer-og-mappestruktur",
    "title": "11  Arbeidsprosess",
    "section": "11.2 main-filer og mappestruktur",
    "text": "11.2 main-filer og mappestruktur\nGenerelt etterstreber jeg en mappestruktur som er omtrent slik ut:\n.\n└── mitt_prosjekt\n    ├── R\n    │   ├── main.R\n    │   ├── scratchpad.R\n    │   └── functions.R\n    ├── output\n    │   ├── *.xlsx\n    │   └── *.csv\n    ├── data\n    │   ├── *.xlsx\n    │   └── *.csv\n    ├── README.md\n    └── .gitignore\nIngen prosjekter ser akkurat slik ut, men det er et mål. Elementene i mappa:\n\nI mappa R ligger alle kodeskriptene.\nmain.R: dette er et lite skript som laster inn funksjoner fra andre skript, og som kun inneholder de få kodene som trengs for å lage outputen. Vanligvis putter jeg all funksjonalitet inn i funksjoner som jeg putter i ett eller flere egne skript.\nscratchpad.R: jeg har ofte en slik fil hvor jeg skrive alle koder før jeg kopierer dem til rett skript. Dette dokumentet blir dermed gravplass for ikke-fungerende koder. Det er en nyttig måte å arbeide på, fordi jeg i ettertid kan ignorere alt som ligger her. Noen ganger er jeg flink til å slette inneholdet slik at jeg ikke forvirrer meg sjøl seinere. Noen gang blir det liggende. Dere kan alltid ignorere denne fila.\nfunctions.R: Om det kun er ett skript, heter dette vanligvis functions.R. Blir det mange funksjoner og uoversiktelig med alle i ett skript, deler jeg dem opp i flere skript med mer eller mindre beskrivende navn som cleaning-functions.R, import-functions.R, etc.\nI mappa output ligger alle de prosesserte filene. Ofte .csv eller .xlsx filer.\nI mapppa data ligger rådatafilene. I noen prosjekter lasta jeg ned data fra nettet og la her. Andre plasser lasta jeg ned data via API, og lagre en kopi av dem her for å ikke beslaglegge API-en unødvendig. I andre kopierte jeg filer fra M:-disken og la her. Hvis jeg arbeida med filer fra M: pleide jeg vanligvis å oppgi filstien til fila direkte i funksjonen som importerte dataene til R.\nIdeelt sett skulle alle prosjekter har en readMe.md (eller lesMeg.md på norsk). Denne fila (som noen gang blei printa som en pdf) forklarer hva prosjektet handler om.\n.gitignore: denne fila brukes av Git (se ned), og du kan se bort fra den.\n\nShiny-appene har i tillegg en fil som heter app.R, som har samme hovedfunksjon som main.R. Her defineres sjølve appen. Alle skript som ligger i R blir automatisk kjørt når man kjører app.R, i motsetning til main.R hvor man manuelt må kjøre alle skript via source().\nMange av prosjekta er en eksentrisk blanding av engelsk og norsk, som kom av at jeg vanligvis koder på engelsk og dokumenterer på norsk. I enkelte prosjekter var jeg flinkere på være konsekvent enn i andre.\nI noen main-filer har jeg kommentert vekk linjer som produserer data som blir lagra på disk. Dette fordi man kan komme i skade for å kjøre dem uforvarende og skrive over noe. F.eks. i appen fodte-dode har jeg gjort dette. Der ligger en funksjon som er tenkt å kjøres en gang i måneden for å hente nye dødetall via SSBs API."
  },
  {
    "objectID": "arbeidsprosess.html#git",
    "href": "arbeidsprosess.html#git",
    "title": "11  Arbeidsprosess",
    "section": "11.3 Git",
    "text": "11.3 Git\nJeg har brukt Git på alle prosjektene. Git er et version-control system, og nyttig når man koder. Jeg har brukt det for å unngå det vi ser i figuren på side 4 av denne artikkelen: mange versjoner av samme dokument med ulike navn som indikerer hvilken versjon det er snakk om. Kort fortalt sørger Git for at jeg har alle disse gamle versjonene av dokumentene tilgjengelig, men at de ikke vises og tar opp plass i mappestrukturen min. Dermed holder jeg lettere oversikt.\nDere trenger ikke vite noe om Git fordi jeg har sørga for at det alltid er siste versjon som ligger klar. Jeg nevner det likevel fordi dere kan lure på hvorfor det ligger noen filer som heter .git og .gitignore i prosjektene. Disse filene brukes av git. Det kan slette dem uten at det vil ødelegge prosjektene. (Men da vil all historikken gå tapt, og det er ikke lengre mulig å se eldre versjoner av skriptene mine).\nJeg brukte altså Git som en måte å holde orden i filene mine, men også til å sikkerhetskopiere til M-disken. M er som kjent en server vi kobler oss på trådløst. Her lagrer vi alt vi arbeider med (som ikke går på Google disk). Problemet med M er at det er en ekstern server. Dermed kan enkelte prosesser tar mye lengre tid når man arbeider med filer som ligger på M. Dessuten vil en del programmer frike ut dersom tilkoblinga til M blir borte i et mikrosekund, slik den plagsomt nok blir hvis skjermspareren kommer på eller hvis et atom nyser i feil retning. Min løsning blei å jobbe med alt på den lokale C-disken og kopiere over alt til M-disken på slutten av hver dag1. Dette høres tungvint ut, tenker du sikkert. Kopiere over alle filer til et prosjekt hver dag? Huff. Men det var ikke vanskeligere enn å skrive inn dette i en konsoll: git push.\n\n11.3.1 Hva må du vite om Git\nIngen ting. Det holder å vite at jeg brukte Git, og det er derfor visse filer eksisterer i prosjektene. Det er smart å la disse ligge der i fall dere en gang får lyst å bruke Git sjøl. Og for å beholde historikken min (som jeg tviler på at dere noen gang vil ha nytte av).\nDet som ligger i mappa R/sikkerhetskopier på M er essensielt det samme som ville ligget der dersom jeg hadde manuelt dratt filene over. Jeg antar at C-disken på pc-en min blir mind wiped snart, og da vil dette være de eneste kopiene av arbeidet mitt, så dere trenger ikke tenke på hva som er kopi av hva.\n\n\n\nMin pc, snart."
  },
  {
    "objectID": "arbeidsprosess.html#lagringslokasjon",
    "href": "arbeidsprosess.html#lagringslokasjon",
    "title": "11  Arbeidsprosess",
    "section": "11.4 Lagringslokasjon",
    "text": "11.4 Lagringslokasjon\nSom jeg nevnt over arbeida jeg på den lokale C-disken, og opprettholdt sikkerhetskopier på M. For å utbrodere litt på dette: Noen ganger er det vanskelig å arbeide på filer direkte på en ekstern server. Det er ikke helt kosekvent hvordan dette utarter seg. I arbeidet med flytterater skal jeg skrive en excelfil til M-disken. Dette tar flere minutter. Å skrive den til C-disken tar ett sekund. Og å kopiere fra C til M tar sekunder. Dermed er det kjappere å skrive fila til C og så kopiere den til M. R lar oss manipulere filer direkte. Så i denne koden har jeg lagd en funksjon som kopierer det vi trenger fra M til C, og kopierer det ferdige produktet tilbake til M fra C. Vi kan gjøre dette relativt sømløst, slik at brukeren ikke trenger å tenke på hvor filer er lagra. Så lenge vi sjøl har kontroll, så klart.\nSom nevnt tidligere over her og når pakka here omtales, i et prosjekt er alle filstier relative til prosjektets rotmappe. Dermed vil det ikke oppstå noen problemer når det kommer til filer som ligger i en undermappe av prosjektet. F.eks. legger jeg som nevnt datafiler i mappa data. Uansett hvor du kopierer et prosjekt til, så lenge du åpner prosjektet i Rstudio skal disse lenkene fungere (til og med om du åpner dem på en pc med macOS!). Noen filer vi bruker ligger på M. Her er det viktig at disse filstiene bevares eller oppdateres.\nPå statistikkmappene er det en konvensjon at filer med datasett er navngitt etter datoen de blei laga. Det vil si at folkemengdefila jeg henviser til i skriptet fra mars 2023 ikke er den oppdaterte folkemengdefila i mai 2024. Her må man gå inn og oppdatere koden med nytt navn. Hvis man føler seg fancy kan man lage en funksjon som gjetter seg fram til hva som er den nyeste versjonen av en fil."
  },
  {
    "objectID": "arbeidsprosess.html#functional-programming",
    "href": "arbeidsprosess.html#functional-programming",
    "title": "11  Arbeidsprosess",
    "section": "11.5 Functional programming",
    "text": "11.5 Functional programming\nJeg har etterstreba et paradigme som kalles functional programming. Dette er en programmeringsstil hvor vi fokuserer på funksjoner som gjør alt av endringer på data. Resultatet er lettere å lese, forstå og debugge. Les mer om det i Modern R with the tidyverse. I praksis vil det si at jeg putter funksjoner sammen i andre funksjoner som jeg gir beskrivende navn. Dette gjør det lettere å gruppere sammen databehandlingsfunksjoner. Og dermed også å putte funksjoner i ulike skriptfiler. Jeg bytta nylig til denne praksisen, etter å tidligere ha arbeida med meterlange skript hvor objekter opprettes, endres, slettes, transformeres og lagres om hverandre. Så langt syns jeg dette er en stor forbedring. Utfordringa er å finne en god balanse mellom hvor mange skript man skal lage, og hvor mange delfunksjoner man trenger. Du vil se at jeg er inkonsekvent i de ulike prosjekta mine. Her finnes heller ingen one size fits all. Små prosjekter trenger ikke mer enn en main.R-fil. Store prosjekter kan ha mange skript fordelt over flere mapper."
  },
  {
    "objectID": "feil.html#glemt-å-laste-inn-en-pakke",
    "href": "feil.html#glemt-å-laste-inn-en-pakke",
    "title": "12  Typiske feil vi (jeg) gjør og hvordan fikse dem",
    "section": "12.1 Glemt å laste inn en pakke",
    "text": "12.1 Glemt å laste inn en pakke\nJeg starter alle R-sesjoner med å laste inn pakker, og jeg laster nesten alltid inn tidyverse. Hvis jeg glemmer det, vil funksjoner fra denne pakka ikke være tilgjengelig."
  },
  {
    "objectID": "feil.html#laster-inn-pakker-i-feil-rekkefølge",
    "href": "feil.html#laster-inn-pakker-i-feil-rekkefølge",
    "title": "12  Typiske feil vi (jeg) gjør og hvordan fikse dem",
    "section": "12.2 Laster inn pakker i feil rekkefølge",
    "text": "12.2 Laster inn pakker i feil rekkefølge\nDet lønner seg å laste inn pakker i omvendt prioritert rekkefølge. Dette er fordi en del pakker inneholder funksjoner med samme navn, men ulik bruksområde. Da vil den siste pakka du laster inn maskere den tidligere funksjonen. For eksempel inneholder stats funksjonen filter(). Denne blir erstatte med dplyrs filter() når vi laster inn den pakka (often via tidyverse). Jeg pleier dermed ofte å laste inn tidyverse sist. Denne feilen er vanskelig å feilsøke, fordi du kan få en feilmelding uten å ha gjort noe som helst endring i koden. (Les: jeg har kasta bort mye tid på å feilsøke når det viste seg at det eneste jeg hadde gjort var å endre rekkefølgene pakkene blei lasta inn på, slik an funksjon jeg var avhengig av fra pakke1 blei bytta ut med en annen funksjon med samme navn fra pakke2.)\nHusk at det går an å bruke en pakkes funksjon uten å laste den inn ved å bruke ::, slik som i dplyr::filter(). Det bidrar til at å unngå at du får lasta inn for mange pakker som overskriver hverandres funksjoner. Spesielt hvis du bare bruker få funksjoner noen få ganger, kan dette lønne seg. Jeg gjør vanligvis dette når jeg importerer datasett, siden dette er noe jeg kun gjør én gang per prosjekt. Hvis jeg derimot skal eksportere mange filer, vil det spare tastaturet mitt å bare laste inn pakka.\nForøvrig har vi en liknende feil"
  },
  {
    "objectID": "feil.html#jeg-har-ikke-gjort-noen-endringer-men-plutselig-funker-ikke-koden-min",
    "href": "feil.html#jeg-har-ikke-gjort-noen-endringer-men-plutselig-funker-ikke-koden-min",
    "title": "12  Typiske feil vi (jeg) gjør og hvordan fikse dem",
    "section": "12.3 “Jeg har ikke gjort noen endringer, men plutselig funker ikke koden min!”",
    "text": "12.3 “Jeg har ikke gjort noen endringer, men plutselig funker ikke koden min!”\nDette er i prinsippet umulig å feilsøke. Heldigvis kan vi benytte oss av et smertelig nyttig prinsipp: Årsaken er alltid at du har gjort en feil.\nDette skjer typisk dersom du har arbeida lenga i en sesjon uten å restarte R. Første gang du restarter R og kjører koden på nytt får du feilmelding. Da er ofte problemet at du på et tidspunkt har lagra noe i miljøet (environment), som ikke lengre er tilstede i koden. Hvis andre deler av koden er avhengig av dette objektet, vil de feile nå som objektet ikke lengre er tilstede. Du må rett og slett finne ut hvor bruddet skjer, og fikse det.\nEn måte å forebygge dette på er ved å ta i bruke functional programming. Det vil si at vi bruker funksjoner i stor grad og sjelden lagrer objekter direkte i miljøet. Brodrigues forklarer det bedre.\nEn annen måte å forebygge det på er å restarte R-sesjonen ofte. Da unngår du at du arbeider på et gammelt objekt som ikke lenger er fundert i det nåværende skriptet. Jeg pleier alltid restarte R-sesjonen når jeg har fullført et delmål i skriptet. Ofte finner jeg en feil da, f.eks. har jeg gitt nytt navn til en funksjon eller objekt og glemt å endre det i skriptet. Se mer om dette i Section 4.1."
  },
  {
    "objectID": "feil.html#sender-et-objekt-via-pipe-til-en-funksjon-som-ikke-er-pipevennlig",
    "href": "feil.html#sender-et-objekt-via-pipe-til-en-funksjon-som-ikke-er-pipevennlig",
    "title": "12  Typiske feil vi (jeg) gjør og hvordan fikse dem",
    "section": "12.4 Sender et objekt via pipe til en funksjon som ikke er pipevennlig",
    "text": "12.4 Sender et objekt via pipe til en funksjon som ikke er pipevennlig\nPipa (%>%) er nyttig. Så nyttig at jeg bruker den hele tida for å gjøre koden min mer leselig. Vanligvis sender jeg et datasett videre til neste funksjon, for å gjøre noe med datasettet. Det er slik tidyverse-funksjonene funker. Noen ganger sender jeg datasettet til en funksjon som ikke forventer et datasett, og som ikke funker med tidyselect. F.eks. slik vi så i (med-pipe?).\n\n# Dette funker ikke\nmtcars %>% sum(wt)\n\n# Dette funker\nsum(mtcars$wt)\n\n# Eller dette\nmtcars %>% sum(.$wt)"
  },
  {
    "objectID": "feil.html#glemmer-å-bruke-hermetegn-bruker-hermetegn-når-vi-ikke-trenger-hermetegn",
    "href": "feil.html#glemmer-å-bruke-hermetegn-bruker-hermetegn-når-vi-ikke-trenger-hermetegn",
    "title": "12  Typiske feil vi (jeg) gjør og hvordan fikse dem",
    "section": "12.5 Glemmer å bruke hermetegn / bruker hermetegn når vi ikke trenger hermetegn",
    "text": "12.5 Glemmer å bruke hermetegn / bruker hermetegn når vi ikke trenger hermetegn\nHer varierer det nok ut ifra hvor god man er på å forstå strukturer. Jeg gjør denne feilen stadig. Har ikke noe bedre råd enn å alltid prøve begge veier. Det er så klart smart å finne ut av hvorfor man noen ganger bruker hermetegn rundt noe og andre ganger ikke. Essensielt handler det om: Når du bruker hermetegn rundt noe viser du at det er en tekststreng. Når du ikke bruker hermetegn rundt tekst viser du at et er et objekt. Da må objektet finnes i miljøet for at det skal kunne tas i bruk. tidyverse kompliserer dette litt ved at de lar oss henvise til f.eks. kolonnenavn som om de er objekter, f.eks. i:\n\nlibrary(tidyverse)\n\n# OK\nstarwars %>% \n  select(name)\n\n# Feilmelding\nstarwars[name]\n\n# OK\nstarwars[\"name\"]\n\n# OK\nstarwars$name\n\n# Også OK\nstarwars$\"name\"\n\nDenne kompliseringa godtar vi, for det er så mange fordeler med at tidyverse lar oss henvise direkte til kolonner i datasett som om de var objekter."
  },
  {
    "objectID": "feil.html#har-brukt-feil-skråstrek",
    "href": "feil.html#har-brukt-feil-skråstrek",
    "title": "12  Typiske feil vi (jeg) gjør og hvordan fikse dem",
    "section": "12.6 Har brukt feil skråstrek",
    "text": "12.6 Har brukt feil skråstrek\nSkjer oftest på maskiner med Windows som operativsystem og når du leser eller skriver filer. Husk at vi i R må bruke /, ikke \\. Se mer om dette i Section 5.1.3."
  },
  {
    "objectID": "feil.html#forveksler-og",
    "href": "feil.html#forveksler-og",
    "title": "12  Typiske feil vi (jeg) gjør og hvordan fikse dem",
    "section": "12.7 Forveksler = og ==",
    "text": "12.7 Forveksler = og ==\n== brukes når du skal sammenlikne to betingelser. = brukes enten til assignment hvis du ikke bruker <-, eller i argumenter. Eksempel:\n\ntrondelag %>% \n  filter(kommune == \"Trondheim\")\n\nbefolkning %>% \n  mutate(er_tronder = if_else(\"skinnvest\" == TRUE & \"bart\" == TRUE, \n                           \"tronder\", \n                           \"ikke_tronder\"))"
  },
  {
    "objectID": "feil.html#tegnkode",
    "href": "feil.html#tegnkode",
    "title": "12  Typiske feil vi (jeg) gjør og hvordan fikse dem",
    "section": "12.8 Tegnkode",
    "text": "12.8 Tegnkode\nTegnkoding er dessverre noe besværlig. Det er flere ting som kan skje her:\n\nFila vi laster inn har en spesifikk tegnkode og vi må definere denne når vi laster inn\nR eller Rstudio sin standardtegnkode er ikke den vi vil ha.\nR eller Rstudio skifte uforvarende tegnkode uten at vi veit hvorfor.\n\nJeg tror noe av dette skyldes bugs i R og Rstudio, for endringsloggen har nevnt at de har fiksa problemer knytta til character encoding.\nSe Section 5.1.4 for mer om dette.\nEllers er min erfaring at det ofte hjelper å restarte R-sesjonen dersom filene du laster inn plutselig mangler æ, ø og å når de tidligere hadde dem. I arbeidet med SSBs API opplevde jeg at filer som tidligere blei lasta inn med norske bokstaver rett som det var dukka opp med andre tegn istedenfor. Her fant jeg aldri ut hva som forårsaka det, men det funka alltid å restarte R-sesjonen. Kanskje var det noen pakker som når de blei lasta inn overskreiv noe annet. Dette gir oss en R-aforisme:\n\nDet er bedre å fikse et problem enn å forstå problemet."
  },
  {
    "objectID": "feil.html#jeg-har-prøvd-alt-men-ingenting-løser-problemet-mitt",
    "href": "feil.html#jeg-har-prøvd-alt-men-ingenting-løser-problemet-mitt",
    "title": "12  Typiske feil vi (jeg) gjør og hvordan fikse dem",
    "section": "12.9 Jeg har prøvd alt, men ingenting løser problemet mitt",
    "text": "12.9 Jeg har prøvd alt, men ingenting løser problemet mitt\nHer er en generell sti du kan gå ned når du skal løse et problem i R:\n\nRestart R-sesjonen\nRestart Rstudio\nRestart datamaskina\nOppdater R (valgfri, noen gang skummelt)\nOppdater Rstudio\nSpør en kollega\nSpør på StackOverflow eller CrossValidated (husk å gi det et reproduserbart eksempel!)"
  },
  {
    "objectID": "references.html#ressurser-for-å-lære-r",
    "href": "references.html#ressurser-for-å-lære-r",
    "title": "Referanser",
    "section": "Ressurser for å lære R",
    "text": "Ressurser for å lære R\nR for data science: En bok med nyttige tips for bruk av tidyverse på arbeidsmåter som er lik våre egne. Forfatter Hadley Wickham er den viktigste personen bak tidyverse, og skriver gode lærebøker.\nAdvanced R: Oppfølgeren til forrige bok, av samme forfatter. Mer R, mer avansert, samme pedagogiske stil. Jeg nevner den her fordi det er en bok jeg ofte blir henvist til når jeg søker opp hvordan jeg skal gjøre et eller annet i R.\nPosits jukselapper: Uvurderlige dokumenter! Posit er selskapet bak Rstudio, og er forøvrig hvor stjernen Hadley Wickham jobber. De har laga disse to-siders pdf-ene som oppsummerer på en kompakt og visuell måte hvordan hovedfunksjonene fra tidyverse-pakkene fungerer. Dette er de dokumentene jeg bruker mest når jeg arbeider med R.\nSwirl: Swirl er en pakke som lærer deg R, inni R. Dermed blir det et interaktivt kurs. Har ikke prøvd det sjøl, men har hørt andre anbefale det.\nWhat They Forgot to Teach You About R: En kort bok som ikke er helt ferdig. Den inneholder likevel nyttig informasjon for den som begynner å bli litt vant med R.\nThe tidyverse style guide: Når du har begynt å skrive kode vil du etter hvert merke at du ikke er konsekvent. R som kodespråk gir deg frie tøyler til en viss grad - du kan f.eks. sjøl velge om du vil ha mellomrom mellom operatorer (4+9*3%2 vs. 4 + 9 * 3 % 2). Så vil du også skjønne at det lønner seg å være konsekvent, og at man kan skrive pen kode og stygg kode. Denne stilguiden er en kjapp og grei guide til å skrive pent og konsekvent, noe som vil gjøre det enklere for deg sjøl og andre å lese koden din. En bonus til å lese denne er at den vil gi dere evnen til å oppdage alle gangene jeg synder mot stilguiden i denne pamfletten. Så kan dere le rått og være overbærende.\nRegular expressions: Det er overraskende vanskelig å finne en god guide til regular expression, som vi bruker i blant annet stringr-pakka. Dette er en av de mindre dårlige. Advarsel: Det kan virke overveldende.\nGeocomputation in R: Noen har (selvfølgelig) laga (mange) pakker for å arbeide med kart og geografiske elementer i R. Denne boka gir en grundig introduksjon til det. Jeg sier ikke at vi skal bytte ut ArcGIS og QGIS med R … jeg bare impliserer at det går an."
  },
  {
    "objectID": "references.html#produktiv-prokrastinering",
    "href": "references.html#produktiv-prokrastinering",
    "title": "Referanser",
    "section": "Produktiv prokrastinering",
    "text": "Produktiv prokrastinering\nNoen ganger har man ikke konsentrasjon eller energi til å gjøre det man hadde planlagt. Man kan avspasere, eller … lese om R. Eller forsåvidt en hel del andre ting, men la oss fokusere på R-delen.\nBrodrigues: En statistiker fra Luxembourg med en ph.d. i økonomi som blogger om R og arbeidet i det offentlige. Han er enda mer fanatisk opptatt av åpen kildekode og programmering enn meg, og har mange interessante anvendelser av R på f.eks. Word- og Exceldokumenter. Mye av min skepsis mot Excel kan gjenkjennes hos ham.\nRweekly: En bloggaggregator. Hver uke samles en serie med interessante bloggposter om R. Jeg har oppdaga mange nyttige blogger og funksjoner via slike aggregatorer (blant annet Brodrigues over).\nR-bloggers: Samme som Rweekly, bare at den oppdateres hver dag. Jeg syns kvaliteten på postene i Rweekly er noe høyere, men dersom du har et stort prokrastineringsbehov er denne sida grei å vite om også."
  },
  {
    "objectID": "references.html#enkeltartikler",
    "href": "references.html#enkeltartikler",
    "title": "Referanser",
    "section": "Enkeltartikler",
    "text": "Enkeltartikler\nWhy should I use R: The Excel R Data Wrangling comparison: En sammenlikning av R og Excel. Gjett hva som anbefales. Nyttig for å få en forståelse av hvordan man gjør ting i R som man allerede kan i Excel.\nGraphical User Interfaces were a mistake but you can still make things right: En av mine favorittartikler hos Brodrigues, med en herlig provoserende tittel.\nData in government: RAPpers delight: En artikkel fra en gruppe statistikere som brukte en reproduserbar analyse pipeline (RAP). Dette er en teknikk som R muliggjør, og som er interessant for alle som jobber med statistikk i det offentlige.\nData processing in Sas, Spss, Stata, R and Python. A comparison: SSBs sammenlikning av de ulike, vanlige statistikkprogramma og hvordan man gjør samme operasjon i dem. Nyttig dersom man har en SPSS-syntaks man vil gjenskape i R (eller motsatt!).\nSPSS syntax to R: I samme gate, NHS i Skottland har laga en nyttig oversikt over noen av SPSSs mest vanlige kommandoer og hva det tilsvarende er i R."
  },
  {
    "objectID": "praktisk-eksempel.html#oppgavebeskrivelse",
    "href": "praktisk-eksempel.html#oppgavebeskrivelse",
    "title": "Appendix A — Et praktisk eksempel",
    "section": "A.1 Oppgavebeskrivelse",
    "text": "A.1 Oppgavebeskrivelse\nVi vil laste inn to SPSS-datasett. Det ene ligger i en undermappe (relativt til skriptet) kalt data. Det andre ligger godt hjem langt, langt vekk et sted på C-disken min. Vi vil laste inn begge to og se hvordan det de ser ut.\n\n# For å laste inn SPSS-filer trenger vi en pakke som gjør det. Haven er bra.\n# Dersom du ikke har haven fra før må den installeres. En pakke trenger bare \n# installeres  én gang. Siden jeg har pakka fra før har\n# jeg kommentert vekk neste kode for. Skal du installere koden, fjern \n# emneknaggen.\n\n# install.packages(\"haven\")\n\n# Så må vi laste inn pakka for å kunne ta dens funksjoner i bruk. Dette må vi\n# gjøre hver gang vi starter en ny sesjon.\n\nlibrary(haven)\n\n# Vi laster inn den første SPSS-fila. Vi gir den navnet atferd. Siden den \n# ligger på mappa data må vi spesifisere dette når vi oppgir hvor den ligger og\n# hva den heter. Husk også filendelsen. Noen operativsystem er glad i skjule \n# fil-endelsen, men den er en viktig del av alle filers navn.\natferd <- read_sav(file = \"data/behavior.sav\")\n\n# Den andre fila ligger langt vekk på C. For å gjøre det litt enklere for meg\n# sjøl vil jeg lagre filstien (og navnet) i en vektor. Jeg gjør ofte dette om \n# filstien er lang, for å ikke gjøre import-funksjonen så lang.\n# Husk dette med skråstreker: Vi må enten bruke \\\\ eller /, ikke en enkelt \\\nfilsti <- \"C:\\\\Program Files\\\\IBM\\\\SPSS\\\\Statistics\\\\26\\\\Samples\\\\English\\\\accidents.sav\"\n\n# Så laster vi inn den andre fila. \nulykker <- read_sav(file = filsti)\n\n# Dette er altså det samme som å skrive \n# ulykker <- read_sav(file = \"C:\\\\Program Files\\\\IBM\\\\SPSS\\\\Statistics\\\\26\\\\Samples\\\\English\\\\accidents.sav\")\n# Siden vi definerte filsti tidligere. \n\n# Nå har vi fått de to datasetta våre. Hvordan ser de ut?\n\nsummary(atferd)\n\n     ROWID           Run             Talk            Kiss           Write      \n Min.   : 1.0   Min.   :1.060   Min.   :0.420   Min.   :0.270   Min.   :0.710  \n 1st Qu.: 4.5   1st Qu.:4.300   1st Qu.:0.560   1st Qu.:2.625   1st Qu.:2.810  \n Median : 8.0   Median :6.440   Median :0.920   Median :4.080   Median :4.440  \n Mean   : 8.0   Mean   :5.539   Mean   :1.523   Mean   :3.996   Mean   :4.166  \n 3rd Qu.:11.5   3rd Qu.:7.050   3rd Qu.:1.675   3rd Qu.:5.460   3rd Qu.:5.790  \n Max.   :15.0   Max.   :7.620   Max.   :5.710   Max.   :7.920   Max.   :6.420  \n      Eat            Sleep           Mumble           Read      \n Min.   :0.560   Min.   :0.150   Min.   :1.330   Min.   :0.420  \n 1st Qu.:1.135   1st Qu.:4.145   1st Qu.:3.685   1st Qu.:1.780  \n Median :1.810   Median :6.020   Median :3.960   Median :4.290  \n Mean   :3.148   Mean   :5.311   Mean   :4.431   Mean   :3.905  \n 3rd Qu.:4.470   3rd Qu.:6.970   3rd Qu.:5.430   3rd Qu.:5.365  \n Max.   :7.620   Max.   :8.250   Max.   :7.690   Max.   :7.270  \n     Fight           Belch           Argue            Jump      \n Min.   :4.750   Min.   :2.190   Min.   :1.480   Min.   :1.580  \n 1st Qu.:6.780   1st Qu.:4.500   1st Qu.:4.070   1st Qu.:4.500  \n Median :7.330   Median :6.420   Median :4.830   Median :5.460  \n Mean   :7.035   Mean   :5.731   Mean   :5.027   Mean   :5.265  \n 3rd Qu.:7.585   3rd Qu.:6.810   3rd Qu.:6.085   3rd Qu.:6.795  \n Max.   :8.380   Max.   :7.790   Max.   :7.290   Max.   :7.520  \n      Cry            Laugh           Shout      \n Min.   :1.000   Min.   :0.770   Min.   :1.060  \n 1st Qu.:4.450   1st Qu.:1.030   1st Qu.:4.495  \n Median :5.520   Median :1.600   Median :5.480  \n Mean   :4.999   Mean   :1.993   Mean   :5.317  \n 3rd Qu.:5.895   3rd Qu.:2.500   3rd Qu.:7.050  \n Max.   :7.630   Max.   :6.400   Max.   :7.670  \n\nsummary(ulykker)\n\n     agecat         gender        accid            pop        \n Min.   :1.00   Min.   :0.0   Min.   :54123   Min.   :187791  \n 1st Qu.:1.25   1st Qu.:0.0   1st Qu.:57334   1st Qu.:196416  \n Median :2.00   Median :0.5   Median :60967   Median :199633  \n Mean   :2.00   Mean   :0.5   Mean   :60801   Mean   :199035  \n 3rd Qu.:2.75   3rd Qu.:1.0   3rd Qu.:64610   3rd Qu.:202586  \n Max.   :3.00   Max.   :1.0   Max.   :66804   Max.   :208239  \n\n\nDatasetta er forøvrig lånt fra SPSS. Du trenger ikke bruke disse datasetta i din egen gjennomgang, bare finn to andre. Putt dem gjerne på forskjellige plasser for å øve på å laste dem inn fra ulik lokasjon. Hvis du putter filstien i en vektor slik jeg gjorde i det ene eksemplet, husk at du enten må putte begge filstiene i ulike objekter, eller at du må laste inn den første fila før du overskriver filstia med den andre filas filsti.\n\n# Dette funker\nfilsti_atferd <- \"data/behavior.sav\"\nfilsti_ulykker <- \"C:\\\\Program Files\\\\IBM\\\\SPSS\\\\Statistics\\\\26\\\\Samples\\\\English\\\\accidents.sav\"\n\natferd <- read_sav(file = filsti_atferd)\natferd <- read_sav(file = filsti_ulykker)\n\n# Dette funker også, men du må huske på å aldri endre rekkefølgen.\nfilsti <- \"data/behavior.sav\"\natferd <- read_sav(file = filsti)\n\nfilsti <- \"C:\\\\Program Files\\\\IBM\\\\SPSS\\\\Statistics\\\\26\\\\Samples\\\\English\\\\accidents.sav\"\nulykker <- read_sav(file = filsti)\n\n# Dette vil laste inn det samme datasettet to ganger, og dem ulike navn.\n# Begge vil være ulykker, hvis filsti blei definert sist.\nfilsti <- \"data/behavior.sav\"\nfilsti <- \"C:\\\\Program Files\\\\IBM\\\\SPSS\\\\Statistics\\\\26\\\\Samples\\\\English\\\\accidents.sav\"\n\natferd <- read_sav(file = filsti)\nulykker <- read_sav(file = filsti)"
  },
  {
    "objectID": "assortert.html#avruding-i-r",
    "href": "assortert.html#avruding-i-r",
    "title": "Appendix A — Assorterte notater jeg ikke greide å presse inn andre steder",
    "section": "A.1 Avruding i R",
    "text": "A.1 Avruding i R\nR følger visst en annen avrundingsregel enn SPSS, hvor 0.5 blir runda ned til 0 istedenfor opp til 1 slik vi nok er vant til. Dette er matematisk innafor å gjøre, men kan føre til at R gir andre tall enn vi får fra SPSS, sjøl om utgangspunktet er likt. Om det har noe å si avhenger av hvor mange desimalposisjoner man har i utgangspunktet. I arbeidet med boligflytterater fant jeg kun forskjeller hvis jeg hadde med 14 desimaltall. Det var nok ikke en viktig forskjell. Du kan lese mer om dette i skotske NHS’ artikkel om temaet."
  },
  {
    "objectID": "assortert.html#iterering-og-funksjonsfamilien-map",
    "href": "assortert.html#iterering-og-funksjonsfamilien-map",
    "title": "Appendix A — Assorterte notater jeg ikke greide å presse inn andre steder",
    "section": "A.2 Iterering og funksjonsfamilien map",
    "text": "A.2 Iterering og funksjonsfamilien map\nNoe av det kraftigste og nyttigste med kodespråk er muligheten til å lage løkker (loops). Hvis du veit dette er du kanskje overraska over at vi nesten ikke bruker løkker i R. Årsaken er at løkker er mindre effektive i R siden vi har implementert dette vektorbaserte perspektivet på objekter, som nevnt i starten av pamfletten. Istedenfor tilbyr R en serie med funksjoner kalt apply() eller liknende. Andre funksjoner i denne familien er lapply(), tapply(), etc.\nTidyverse har (så klart) implementert sin egen variant at disse funksjonene som heter map(). Å lære seg map() er definitivt verdt det fordi det lar oss iterere over datasett og gjøre transformasjoner på mange objekter samtidig. Se for deg at vi kjører én kode for å lage befolkningsframskrivninger for alle kommunene i Trondheimsregionen samtidig, istedenfor å gjøre det en etter en. Det er (i teorien) mulig via map().\nNår det er sagt, map() er definitivt et viderekommende tema for en R-bruker. Jeg har så vidt begynt å bruke det, og du kan se det i noen av prosjektene mine. Jeg gjør ikke noe forsøk på å forklare det her, men jeg ville nevne det fordi det er nyttig å være klar over.\nmap()-funksjonene kommer fra pakka purrr, og har kanskje den beste pakkelogoen av alle R-pakker. Dokumentasjonen gir en introduksjon til paradigmet."
  }
]