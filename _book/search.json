[
  {
    "objectID": "omR.html#spss",
    "href": "omR.html#spss",
    "title": "2  Om R",
    "section": "2.1 SPSS",
    "text": "2.1 SPSS\nR er mest likt SPSS, og spesielt SPSS’ syntaks. Til forskjell fra SPSS er ikke det grafiske brukergrensesnittet (GUI) noe særlig nyttig i R.\nMan kan kjøre R i et GUI som følger med R når man laster programmet, som heter R hva enn versjonsnummeret er, f.eks. R 4.2.2. Men det er bedre å bruke Rstudio til å arbeide med R i. Her får du et bra GUI som blant annet fullfører kodeforslag og har mange andre støttende funksjoner.\nVi arbeider vanligvis i skript, som har forkortelsen .R. Dette er likt SPSS’ syntaksfiler (.sps). Du kan kjøre hele skriptet, eller kun deler av skriptet av gangen. Kjør deler av skriptet ved å enten ha markøren i den linja eller marker flere linjer og trykk ctrl + enter.\nTil motsetning fra SPSS er Rs kodespråk lettere å lese og forstå (personlig mening). Man vil så klart aldri huske alle koder i R, men etter hvert vil en del av dem sitte fordi man bruker dem så ofte. Typiske eksempler på dette er %>%, filter() og mutate(). Se mer om disse i seinere kapitler."
  },
  {
    "objectID": "omR.html#excel",
    "href": "omR.html#excel",
    "title": "2  Om R",
    "section": "2.2 Excel",
    "text": "2.2 Excel\nDet er større forskjell på R og Excel. Excel er bygd rundt det grafiske grensesnittet. Det du ser er det du får (WYSIWYG). Dette har sine fordeler og bakdeler. Den største bakdelen, slik jeg ser det, er at Excel lar deg gjøre dumme ting. F.eks. hoppe over rader, forflytte en kolonne uten å mene det, glemme å markere alle felter, og det verste av alt: slå sammen celler.\nLikevel, det er mange ganger det er bedre å bruke Excel.\nVi kan importere excel-filer til R, hvilket er veldig nyttig. Den største utfordringa med dette er at vi må kjempe mot de bakdelene jeg nevnte over.\n\nI motsetning til både Excel og SPSS så lagrer R dataene bare i internt minne mens du arbeider med dem. Dvs. at du ikke er avhengig av å mellomlagre alt som en .sav, .xlsx., eller .csv-fil. Dette kan bidra til å redusere behovet for mange versjoner av samme fil på ulike tidspunkter."
  },
  {
    "objectID": "omR.html#hvorfor-skal-jeg-bruke-r",
    "href": "omR.html#hvorfor-skal-jeg-bruke-r",
    "title": "2  Om R",
    "section": "2.3 Hvorfor skal jeg bruke R?",
    "text": "2.3 Hvorfor skal jeg bruke R?\nEn typisk tilbakemelding:\n\nDet tar tid å lære, det er en bratt læringskurve, og jeg får feilmeldinger hele tida.\n\nDet er noen fordeler med R som er attraktive for oss:\n\nNår du har laga et skript kan du, uten særlig mange endringer, kjøre skriptet på nytt gang etter gang. Dette sparer deg for mye tid istedenfor å måtte starte på nytt hver gang.\n\nDette er delvis mulig i SPSS-syntaks alt. R oppfordrer i større grad til dette via funksjonene sine, og måten den håndterer data på.\n\nMan kan bruke R til alt. Fra før av kan vi spleise data i SPSS, lage tabeller i Excel, gjøre dem interaktive i Infogram, dele dem via Google sheets, etc. R kan gjøre alt dette i samme programvare/GUI.\nR lese og skrive til de fleste vanlige programmer. Dvs. at vi kan starte en prosess i Excel og så fortsette den i R. Eller vi kan importere en Stata-fil til R, gjøre noen pivots og lagre den som en SPSS-fil. Dermed kan R relativt sømløst puttes inn i arbeidsprosessen. (Enklest blir det så klart å gjøre alt i R.)"
  },
  {
    "objectID": "omR.html#versjonering",
    "href": "omR.html#versjonering",
    "title": "2  Om R",
    "section": "2.4 Versjonering",
    "text": "2.4 Versjonering\nR, Rstudio, og alle pakkene til R kommer i ulike versjoner, f.eks. R v.4.2.2, Rstudio 2023.03.0, etc. Når man installerer en pakke vil den nyeste versjonen som er kompatibel med din versjon av R installeres. Her er noen ting å være oppmerksom på: \n\nNoen nye pakker funker ikke på gamle versjoner av R.\nNoen gamle pakker funker ikke eller litt annerledes på nye versjoner av R.\nNår pakker oppdateres vil noen ganger funksjonene deres endres.\n\nDette er en av bakdelene i tidyverse. De har endra på syntaksen sin slik at tidyverse-syntaks fra 2018 ikke gjelder i 2023. F.eks. pleide man å bruke mutate_at() før i tida for å mutere kun visse rader. Nå bruker man derimot en kombinasjon av mutate() og across() for å oppnå det samme. Dette er irriterende hvis du var vant til den gamle metoden.\n\nDu har alltid tilgang til eldre versjoner av R og Rs pakker. Dette er et viktig kjennetegn ved FOSS (free, open-source software). Hvis du trenger en funksjon fra en gammel versjon av en pakke, kan du alltids nedgradere R-versjonen og laste inn den versjonen av pakka. Jeg nevner det her, men det er mer for viderekommende, og for Linux-fantaster.\n\nPer nå er siste versjon vi har tilgang til på byplankontoret 4.2.3. Hvilken versjon har jeg?\n\nsessionInfo()\n\nR version 4.2.3 (2023-03-15 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 10 x64 (build 19045)\n\nMatrix products: default\n\nlocale:\n[1] LC_COLLATE=nb-NO.UTF-8  LC_CTYPE=nb-NO.UTF-8    LC_MONETARY=nb-NO.UTF-8\n[4] LC_NUMERIC=C            LC_TIME=nb-NO.UTF-8    \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.5.4 compiler_4.2.3    magrittr_2.0.3    fastmap_1.1.0    \n [5] cli_3.4.1         tools_4.2.3       htmltools_0.5.4   rstudioapi_0.14  \n [9] stringi_1.7.8     rmarkdown_2.17    knitr_1.40        stringr_1.4.1    \n[13] xfun_0.34         digest_0.6.30     jsonlite_1.8.3    rlang_1.0.6      \n[17] evaluate_0.17    \n\n\nJeg har forrige versjon, 4.2.2. Grunnen er at IT installerte den nye R-versjonen i dag, og jeg ikke vil ta sjansen på at det er små endringer i koden som ødelegger noe jeg har gjort før. Mest sannsynlig vil det går bra. Små endringer, som å gå fra x.x.2 til x.x.3 vil nok ikke ha noen merkbare endringer.\nTilstedeværelsen av alle disse ulike versjonene av pakker og programvare kan kanskje oppleves som plagsomt. Men det er faktisk en fordel, og en styrke ved R. Det medfører at vi kan garantere at et skript er future proof, at det alltids kan kjøre gitt samme data og datamaskin. Se mer om dette hos Brodrigues. Vi har for eksempel ingen garanti for at Excel i 2030 lar oss åpne og behandle filene våre fra 2020. Eller at alle funksjonene vi har i cellene forstås likt i begge versjonene av Excel. Dette er ikke overdrivelse. Da Excel gikk over fra .xls til .xlsx medførte det at nye versjoner av Excel ikke alltid greide å åpna de gamle filformatene. I denne situasjonen er du avhengig av at du får tilgang på en eldre versjon av programvaren for å åpna fila di. Det er ikke sikkert man får."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduksjon",
    "section": "",
    "text": "Dette er en omfattende dokumentasjon av det jeg har gjort i R på Byplankontoret. I tillegg er det et forsøk på å vise de funksjonene man trenger for å arbeide i R. Det er ufattelig mange muligheter når det kommer til R. Dette er bare et lite utvalg, basert på det jeg har brukt mest."
  },
  {
    "objectID": "pakker.html#tidyverse",
    "href": "pakker.html#tidyverse",
    "title": "3  Pakker",
    "section": "3.1 Tidyverse",
    "text": "3.1 Tidyverse\nTidyverse refererer til\n\nen designfilosofi\nen stor gruppe med pakker\nen spesifikk pakke som grupperer et lite antall pakker\n\nDu kan lese mer om Tidyverse på nettsida deres. Det er også en lærebok som går grundigere gjennom alle funksjonene deres, R for Data Science.\n\n\n\nTidyverse. Fra http://www.seec.uct.ac.za/r-tidyverse\n\n\nNår man kjører library(tidyverse) vil den laste inn alle pakkene nevnt her. Blant annet dplyr, ggplot2, etc. I tillegg laster den inn enkeltfunksjoner fra andre pakker. F.eks. laster den inn pipe operatoren ( %>%) fra magrittr. Mer om den seinere. Dermed er dette egentlig en snarvei for å slippe å laste inn flere pakker.\nTidyverse-pakkene er designa for å harmonisere med hverandre, og det gjør dem veldig sterke. Den underliggende filosofien gir også et bra rammeverk for andre pakker. Vinn-vinn.\nReint praktisk er det sånn at mange av funksjonene i tidyverse allerede eksisterer i base R. F.eks. filtrering, mutering, og etter R v.4.1., pipe-funksjonen. Jeg bruker likevel tidyverse-variantene fordi disse er så mye lettere å forstå, skrive, og lese. De er utvikla for folk som jobber som oss, med tabeller og datasett. Som nybegynner er det ikke bare bare å forstå forskjellen mellom base R og tidyverse, så her er det viktigste:\n\nNår dere søker opp løsninger vil det ofte presenteres løsninger både i base R og i tidyverse. Dette skjer ofte på StackOverflow.\nDe fleste tidyverse-funksjoner har et datasett som første argument i funksjonen. Dette gjør at vi lett kan pipe funksjoner etter hverandre."
  },
  {
    "objectID": "pakker.html#piper",
    "href": "pakker.html#piper",
    "title": "3  Pakker",
    "section": "3.2 Piper",
    "text": "3.2 Piper\nHvorfor er piper så nyttig? De lar oss flette sammen en serie operasjoner uten å måtte mellomlagre objekter. La oss si at vi har et datasett med biler og deres egenskaper. Vi vil\n\nfiltrere ut dem som har under seks sylindre\ngjøre om vekta fra lbs. til kg.\ngruppere etter antall gir\nvise snitt av miles/gallon (mpg).\n\n\n3.2.1 Uten pipa\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.3.6      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\nmtcars <- mtcars\ncars_filtered <- filter(mtcars, cyl >= 6)\ncars_filtered_kg <- mutate(cars_filtered, wt = wt * 0.45359237)\ncars_filtered_kg_grouped <- group_by(cars_filtered_kg, gear)\ncars_filtered_kg_grouped_mean <- summarise(cars_filtered_kg_grouped, snitt = mean(mpg))\n\ncars_filtered_kg_grouped_mean\n\n# A tibble: 3 × 2\n   gear snitt\n  <dbl> <dbl>\n1     3  15.7\n2     4  19.8\n3     5  16.8\n\n\n\n\n3.2.2 Med pipa\n\nlibrary(tidyverse)\ncars_filtered_kg_group_mean <- mtcars %>% \n  filter(cyl >= 6) %>% \n  mutate(wt = wt * 0.45359237) %>% \n  group_by(gear) %>% \n  summarise(snitt = mean(mpg))\n\ncars_filtered_kg_grouped_mean\n\n# A tibble: 3 × 2\n   gear snitt\n  <dbl> <dbl>\n1     3  15.7\n2     4  19.8\n3     5  16.8\n\n\nDet andre eksemplet er\n\nmer lesbart\nmindre stappfult av midlertidige objekter som vi seinere må slette\n\nJeg kommer til å bruke piper en god del både her og i alle skriptene mine. Så det er greit å vite hva det går ut på. Syntaksen x %>% y kan leses som y får x. Vi tar x og sender det til y som tar det inn som sitt første argument. Tidyverse-funksjonene er bygd rundt ideen om at det første argumentet til funksjonene er et datasett. Legg merke til at det er et datasett som er det første objektet i alle funksjonen jeg bruker i eksemplet uten pipe.\nNoen funksjoner, som base::sum() har ikke data som sitt første argument, men en vektor. Hvis man sender et datasett til sum() vil man få en feilmelding.\n\nmtcars %>% sum(wt)\n\nError in mtcars %>% sum(wt): object 'wt' not found\n\n\nFor å få slike funksjoner til å funkere med ei pipe, kan man ofte bruke en funksjon fra magrittr:\n\nmtcars %>% sum(.$wt)\n\n[1] 14045.15\n\n\n. blir her et alias for det aktuelle datasett, og dette er det samme som å skrive:\n\nsum(mtcars$wt)\n\n[1] 102.952\n\n\nDa jeg lærte R var det %>% fra magrittr som var den gjeldende pipa. Den var så nyttig at ei pipe til slutt blei inkorporert i base R. Dette skjedde i R 4.1.0. Base Rs pipe ser slik ut: |>. Den fungerer i hovedsak lik %>%. Når jeg fortsetter å bruke den gamle magrittr-pipa er det bare fordi jeg er gammel og ikke liker å endre på ting som funker. Dessuten har Rstudio en flott snarvei til %>% via ctrl + shift + M.\nDere velger altså sjøl om dere går for %>% eller |>. Husk bare at for å bruke %>% så må tidyverse eller magrittr lastes inn først. (tidyverse låner noen av funksjonene fra magrittr, men laster ikke inn alle funksjonene fra den pakka)."
  },
  {
    "objectID": "references.html#ressurser-for-å-lære-r",
    "href": "references.html#ressurser-for-å-lære-r",
    "title": "Referanser",
    "section": "Ressurser for å lære R",
    "text": "Ressurser for å lære R\nR for data science\nAdvanced R\nSwirl\nWhat They Forgot to Teach You About R"
  },
  {
    "objectID": "references.html#produktiv-prokrastinering",
    "href": "references.html#produktiv-prokrastinering",
    "title": "Referanser",
    "section": "Produktiv prokrastinering",
    "text": "Produktiv prokrastinering\nBrodrigues\nRweekly\nRbloggers"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R for Byplankontoret",
    "section": "",
    "text": "Forord\nDette er en pamflet skrevet for Byplankontorets statistikere, for å gi en kort introduksjon til R. Teksten er skrevet i Quarto."
  },
  {
    "objectID": "grunnleggende.html",
    "href": "grunnleggende.html",
    "title": "4  Det grunnleggende",
    "section": "",
    "text": "5 Data frame\nVi arbeider mest med datasett, og disse har en egen klasse i R, nemlig data frame. Jeg kommer ikke på noen god norsk oversettelse av data frame, så jeg bruker det engelske ordet. Dette fordi jeg på engelsk ville skilt mellom datasets, altså et datasett som kunne finnes i ulike dataformater (.sav, .csv, .xlsx) og data frames, altså en datastruktur i R.\nDet interessante med data frames er at de faktisk bare er lister. Det vil si at mye av det vi veit om lister kan brukes på data frames. Et data frame er strengt tatt bare ei liste med vektorer. Hver vektor blir en kolonne i data framen. Hva representerer hver rad? Det er ikke gitt, men vi kan vanligvis tenke på hver rad som en observasjon. Når vi prater om tidy data vil dette bli utdypa.\nDet er noen begrensninger eller krav ved datasett: hver kolonne må ha lik lengde. Hvis ikke får du feilmelding.\nR er snill og gir oss tydelig beskjed om hva som er galt i feilmeldinga.\nEn ting som er fint med alle disse R-pakkene, er at de ofte inkluderer datasett som vi kan bruke for å illustrere pakkens funksjoner. Disse datasetta ligger tilgjengelig på samme måte som funksjonene: man bare skriver navnet dens for å påkalle den. La oss hente et datasett som kommer fra dplyr (som er en del av tidyverse).\nDet kan føles rart å jobbe med data som vi ikke veit hvor ligger. Så jeg kan plassere det explisitt i miljøet vårt (environment), ved å assigne det.\nLa oss bruke dette datasettet for å vise noen flere egenskaper ved R. Men vent, er dette et data frame?"
  },
  {
    "objectID": "grunnleggende.html#vektor",
    "href": "grunnleggende.html#vektor",
    "title": "4  Det grunnleggende",
    "section": "4.1 Vektor",
    "text": "4.1 Vektor\nDet grunnleggende elementet i R er en vektor. En vektor kan forstås som en liste av elementer med samme type. Vi kan ha vektorer av tall, bokstaver, faktorer. De tre siste er eksempler på klasser. Det er noen forskjellige klasser, men vi bryr oss mest om disse tre.\nLa oss lage en vektor\n\nc(1, 2, 3)\n\n[1] 1 2 3\n\n\nFunksjonen c() kombinerer verdier til en vektor.\nNår vi skriver en kommando vil R alltid returnere noe til oss. Det blir vanligvis printa til skjermen. Hvis vi heller vi lagre det som et objekt som vi kan henvise til seinere, bruker vi assignment for å gi verdien(e) til et objekt vi navngir.\nSlik:\n\nvektor1 <- c(1, 2, 3)\nvektor1\n\n[1] 1 2 3\n\n\nNår man gir en verdi bruker man en av to operatorer: enten <- eller =. Det er generelt ansett at man bør bruke pila istedenfor likhetstegn. Årsakene er\n\n= (assignment) er lett å forveksle med == (comparison). Det er enklere å unngå dette med pila\npila er anvendelig. Du kan faktisk skrive den motsatt vei, slik: c(1, 2, 3) -> vektor1. Når det er sagt, lov meg at du aldri gjør dette med mindre du har en utrolig god grunn. Enkelte konvensjoner er smart å beholde.\n\nDerfor bruker jeg alltid <-, og anbefaler deg det også.\nTall kan man, som vi ser, bare skrive rett ut. Bokstaver, derimot, må deklareres som en streng. Dette gjøres ved å omkranse dem i hermetegn:\n\nvektor2 <- c(\"A\", \"B\", \"C\")\nvektor2\n\n[1] \"A\" \"B\" \"C\"\n\n\nEn vektor som består av bokstaver eller ord kalles en character vector eller en string.\nVi kommer oss langt med numeriske vektorer og strengvektorer. Her er det verdt å merke at det er forskjellige varianter av numeriske vektorer: De kan være Int, double, eller float. Forskjellen er sjelden viktig for oss, så jeg går ikke inn på det.\n\n4.1.1 Datoer\nDatoer er spesielle verdier i R. Dette lar oss gjøre spesielle ting som å regne ut tidsdifferansen mellom to datoer i dager, måneder eller år, og mange andre nyttige ting. Pakka lubridate inneholder mange nyttige funksjoner som utvider de som ligger i base R. Er lubridate en del av tidyverse? Så klart.\n\n\n4.1.2 Logiske verdier\nDet er også verdt å være oppmerksom på logiske vektorer. Elementer i disse vektorene kan kun være enten TRUE (sann) eller FALSE (usann). De brukes mye i filtrering og testing.\n\n\n4.1.3 Missing (NA)\nDet siste typen element vi må huske på er missing. Alle dataprogrammer har ulik måte å lagre såkalte missing data på. I R vises de som NA. Det er masse vi kunne sagt om NA, mer enn jeg rekker her. Jeg nevner kjapt: En del funksjoner, spesielt i base R liker ikke missing. Blant annet sum(). Den vil gi NA som svar dersom det er missing tilstede i datasettet, hvilket aldri er det vi forventer oss. Disse funksjonene har alltid mulighet til å ignorere missing ved å sette et spesielt argument. F.eks. na.rm = TRUE\n\n# En tilfeldig vektor med missing\nfoo <- c(1, 2, 3, NA)\n\n# Forventer 6, får NA.\nsum(foo)\n\n[1] NA\n\n# Slik ber vi sum ignorere missing.\nsum(foo, na.rm = TRUE)\n\n[1] 6\n\n\nNår vi importerer filer fra andre programmer hender det vi får med oss deres definisjon av missing. F.eks. er missing noen ganger koda som -999 i SPSS-filer. Her kan det skje feil slik at disse verdiene blir til 999 i R. Det skjer sjelden, men det er verdt å være oppmerksom på muligheten for at det skjer.\n\n\n4.1.4 Faktor\nFaktorer (factors) må også nevnes. Disse er nyttige for grupperinger, og noen funksjoner kan merke seg hvilke variabler som er faktorer og utføre heuristikker basert på det. Sjøl syns jeg faktorer er knotete å forholde seg til, så jeg foretrekker å bare bruke strengvektorer.\n\n\n4.1.5 Tilbake til vektorer\nMer inngående info om vektorer og klasser kan finnes her.\nEn vektor kan bestå av alt fra ett til mange elementer. Men den kan bare bestå av elementer av samme klasse"
  },
  {
    "objectID": "grunnleggende.html#liste",
    "href": "grunnleggende.html#liste",
    "title": "4  Det grunnleggende",
    "section": "4.2 Liste",
    "text": "4.2 Liste\nEn liste er som en vektor på stereoider. Den kan består av elementer av ulik klasse. I tillegg kan en liste bestå av andre lister. Det gjør dem kraftig, og anvendbar.\n\n# En liste bestående av fem tall. Dette kunne like gjerne vært en vektor\nliste1 <- list(1, 2, 3, 4, 5)\nliste1\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n[[4]]\n[1] 4\n\n[[5]]\n[1] 5\n\n# Denne lista har elementer av ulik klasse.\nliste1 <- list(1, \"B\", 3, \"D\", 5)\nliste1\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"B\"\n\n[[3]]\n[1] 3\n\n[[4]]\n[1] \"D\"\n\n[[5]]\n[1] 5\n\n# En liste bestående av flere vektorer og lister. \nliste2 <- list(\n  vektorA = c(1, 2, 3, 4),\n  vektorB = c(\"ET\", \"IJ\", \"SW\"), \n  liste1 = list(3, 4, 5)\n)\nliste2\n\n$vektorA\n[1] 1 2 3 4\n\n$vektorB\n[1] \"ET\" \"IJ\" \"SW\"\n\n$liste1\n$liste1[[1]]\n[1] 3\n\n$liste1[[2]]\n[1] 4\n\n$liste1[[3]]\n[1] 5\n\n\nVi får direkte tilgang på elementene av objekter ved å bruke firkantklammer ([], a.k.a. hakeparentes, square brackets, box brackets). Da bruker vi indeksen til elementet for å henvise til det. Indeksen er rekkefølga til elementet. R er 1-indeksert. Det vil si at indeksen starter på 1. Andre programmeringsspråk, slik som Python, starter på 0. Seinere skal vi se at det går an å henvise til elementer ut fra navna deres, men det tar vi når vi kommer til det.\n\n# Hva er det første elementet i vektor1?\nvektor1[1]\n\n[1] 1\n\n# Hva er det andre elementet i liste2?\nliste2[2]\n\n$vektorB\n[1] \"ET\" \"IJ\" \"SW\"\n\n\nSpesielt når vi holder på med lister er det verdt å vite om dobbel firkantklammer ([[]]). Vanlige firkantklammer gir deg ei liste med element(ene) på denne indeksen. Doble firkantklammer gir deg sjølve element(ene) på denne indeksen. Du kan se forskjellen her:\n\n# Sjølve det som blir returnert.\nliste2[2] \n\n$vektorB\n[1] \"ET\" \"IJ\" \"SW\"\n\nliste2[[2]]\n\n[1] \"ET\" \"IJ\" \"SW\"\n\n# Det blir tydeligere om vi undersøker klassen til objektene som blir returnert\nliste2[2] %>% class() # liste\n\n[1] \"list\"\n\nliste2[[2]] %>% class() # character (alstå en tekstvektor)\n\n[1] \"character\"\n\n\nVi bruker ikke så ofte lister direkte, men de er viktige av årsaker som straks blir klart. Det siste jeg vil påpeke om lister er at de er rekursive, det vil si at du kan ha ei liste som et element av ei liste. Dermed følger det at vi kan ha ei liste som er et element av ei liste som er et element av ei liste som …\n\n\n\nOg så videre"
  },
  {
    "objectID": "grunnleggende.html#tilbake-til-elementer",
    "href": "grunnleggende.html#tilbake-til-elementer",
    "title": "4  Det grunnleggende",
    "section": "5.1 Tilbake til elementer",
    "text": "5.1 Tilbake til elementer\nNå som vi har tilgang til et større datasett kan vi utforske litt mer hvordan vi arbeider med, nettopp, større datasett. Datasettet starwars inneholder informasjon om dokumentarserien Star Wars, som omhandla livet i gamle dager, i en galakse langt, langt vekk.\n\nstarwars\n\n# A tibble: 87 × 14\n   name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵\n   <chr>        <int> <dbl> <chr>   <chr>   <chr>     <dbl> <chr> <chr>  <chr>  \n 1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…\n 2 C-3PO          167    75 <NA>    gold    yellow    112   none  mascu… Tatooi…\n 3 R2-D2           96    32 <NA>    white,… red        33   none  mascu… Naboo  \n 4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…\n 5 Leia Organa    150    49 brown   light   brown      19   fema… femin… Aldera…\n 6 Owen Lars      178   120 brown,… light   blue       52   male  mascu… Tatooi…\n 7 Beru White…    165    75 brown   light   blue       47   fema… femin… Tatooi…\n 8 R5-D4           97    32 <NA>    white,… red        NA   none  mascu… Tatooi…\n 9 Biggs Dark…    183    84 black   light   brown      24   male  mascu… Tatooi…\n10 Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon\n# … with 77 more rows, 4 more variables: species <chr>, films <list>,\n#   vehicles <list>, starships <list>, and abbreviated variable names\n#   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld\n\n\nPå tide å utforske. Vi kan henvise til spesifikke celler via x- og y-koordinater.\n\n# Vi kan finne en nøyaktig celle ved å henvise til x- og y-koordinatene\nstarwars[2, 1]\n\n# A tibble: 1 × 1\n  name \n  <chr>\n1 C-3PO\n\nstarwars[5, 4]\n\n# A tibble: 1 × 1\n  hair_color\n  <chr>     \n1 brown     \n\n# Vi kan få tak i en serie med elementer via `:`\nstarwars[1:3]\n\n# A tibble: 87 × 3\n   name               height  mass\n   <chr>               <int> <dbl>\n 1 Luke Skywalker        172    77\n 2 C-3PO                 167    75\n 3 R2-D2                  96    32\n 4 Darth Vader           202   136\n 5 Leia Organa           150    49\n 6 Owen Lars             178   120\n 7 Beru Whitesun lars    165    75\n 8 R5-D4                  97    32\n 9 Biggs Darklighter     183    84\n10 Obi-Wan Kenobi        182    77\n# … with 77 more rows\n\n# Vi kan gjøre et utvalg av celler ved å definere både x og y som en serie\nstarwars[2:5, 6:9]\n\n# A tibble: 4 × 4\n  eye_color birth_year sex    gender   \n  <chr>          <dbl> <chr>  <chr>    \n1 yellow         112   none   masculine\n2 red             33   none   masculine\n3 yellow          41.9 male   masculine\n4 brown           19   female feminine \n\n\nDet er upraktisk å skulle huske indekser til alt. Heldigvis kan vi henvise til kolonner dersom de er navngitt, slik som her:\n\nstarwars[\"eye_color\"]\n\n# A tibble: 87 × 1\n   eye_color\n   <chr>    \n 1 blue     \n 2 yellow   \n 3 red      \n 4 yellow   \n 5 brown    \n 6 blue     \n 7 blue     \n 8 red      \n 9 brown    \n10 blue-gray\n# … with 77 more rows\n\n# En nyttig funksjon for å finne navna til alle kolonnene (variablene) er:\ncolnames(starwars)\n\n [1] \"name\"       \"height\"     \"mass\"       \"hair_color\" \"skin_color\"\n [6] \"eye_color\"  \"birth_year\" \"sex\"        \"gender\"     \"homeworld\" \n[11] \"species\"    \"films\"      \"vehicles\"   \"starships\" \n\nstarwars[\"species\"]\n\n# A tibble: 87 × 1\n   species\n   <chr>  \n 1 Human  \n 2 Droid  \n 3 Droid  \n 4 Human  \n 5 Human  \n 6 Human  \n 7 Human  \n 8 Droid  \n 9 Human  \n10 Human  \n# … with 77 more rows\n\n\nEt alterntiv til klammeparantesen er å bruke operatoren `$´.\n\n# Her trenger man ikke hermetegn, med mindre kolonna har mellomrom.\nstarwars$name\n\n [1] \"Luke Skywalker\"        \"C-3PO\"                 \"R2-D2\"                \n [4] \"Darth Vader\"           \"Leia Organa\"           \"Owen Lars\"            \n [7] \"Beru Whitesun lars\"    \"R5-D4\"                 \"Biggs Darklighter\"    \n[10] \"Obi-Wan Kenobi\"        \"Anakin Skywalker\"      \"Wilhuff Tarkin\"       \n[13] \"Chewbacca\"             \"Han Solo\"              \"Greedo\"               \n[16] \"Jabba Desilijic Tiure\" \"Wedge Antilles\"        \"Jek Tono Porkins\"     \n[19] \"Yoda\"                  \"Palpatine\"             \"Boba Fett\"            \n[22] \"IG-88\"                 \"Bossk\"                 \"Lando Calrissian\"     \n[25] \"Lobot\"                 \"Ackbar\"                \"Mon Mothma\"           \n[28] \"Arvel Crynyd\"          \"Wicket Systri Warrick\" \"Nien Nunb\"            \n[31] \"Qui-Gon Jinn\"          \"Nute Gunray\"           \"Finis Valorum\"        \n[34] \"Jar Jar Binks\"         \"Roos Tarpals\"          \"Rugor Nass\"           \n[37] \"Ric Olié\"              \"Watto\"                 \"Sebulba\"              \n[40] \"Quarsh Panaka\"         \"Shmi Skywalker\"        \"Darth Maul\"           \n[43] \"Bib Fortuna\"           \"Ayla Secura\"           \"Dud Bolt\"             \n[46] \"Gasgano\"               \"Ben Quadinaros\"        \"Mace Windu\"           \n[49] \"Ki-Adi-Mundi\"          \"Kit Fisto\"             \"Eeth Koth\"            \n[52] \"Adi Gallia\"            \"Saesee Tiin\"           \"Yarael Poof\"          \n[55] \"Plo Koon\"              \"Mas Amedda\"            \"Gregar Typho\"         \n[58] \"Cordé\"                 \"Cliegg Lars\"           \"Poggle the Lesser\"    \n[61] \"Luminara Unduli\"       \"Barriss Offee\"         \"Dormé\"                \n[64] \"Dooku\"                 \"Bail Prestor Organa\"   \"Jango Fett\"           \n[67] \"Zam Wesell\"            \"Dexter Jettster\"       \"Lama Su\"              \n[70] \"Taun We\"               \"Jocasta Nu\"            \"Ratts Tyerell\"        \n[73] \"R4-P17\"                \"Wat Tambor\"            \"San Hill\"             \n[76] \"Shaak Ti\"              \"Grievous\"              \"Tarfful\"              \n[79] \"Raymus Antilles\"       \"Sly Moore\"             \"Tion Medon\"           \n[82] \"Finn\"                  \"Rey\"                   \"Poe Dameron\"          \n[85] \"BB8\"                   \"Captain Phasma\"        \"Padmé Amidala\"        \n\nstarwars$\"name\"\n\n [1] \"Luke Skywalker\"        \"C-3PO\"                 \"R2-D2\"                \n [4] \"Darth Vader\"           \"Leia Organa\"           \"Owen Lars\"            \n [7] \"Beru Whitesun lars\"    \"R5-D4\"                 \"Biggs Darklighter\"    \n[10] \"Obi-Wan Kenobi\"        \"Anakin Skywalker\"      \"Wilhuff Tarkin\"       \n[13] \"Chewbacca\"             \"Han Solo\"              \"Greedo\"               \n[16] \"Jabba Desilijic Tiure\" \"Wedge Antilles\"        \"Jek Tono Porkins\"     \n[19] \"Yoda\"                  \"Palpatine\"             \"Boba Fett\"            \n[22] \"IG-88\"                 \"Bossk\"                 \"Lando Calrissian\"     \n[25] \"Lobot\"                 \"Ackbar\"                \"Mon Mothma\"           \n[28] \"Arvel Crynyd\"          \"Wicket Systri Warrick\" \"Nien Nunb\"            \n[31] \"Qui-Gon Jinn\"          \"Nute Gunray\"           \"Finis Valorum\"        \n[34] \"Jar Jar Binks\"         \"Roos Tarpals\"          \"Rugor Nass\"           \n[37] \"Ric Olié\"              \"Watto\"                 \"Sebulba\"              \n[40] \"Quarsh Panaka\"         \"Shmi Skywalker\"        \"Darth Maul\"           \n[43] \"Bib Fortuna\"           \"Ayla Secura\"           \"Dud Bolt\"             \n[46] \"Gasgano\"               \"Ben Quadinaros\"        \"Mace Windu\"           \n[49] \"Ki-Adi-Mundi\"          \"Kit Fisto\"             \"Eeth Koth\"            \n[52] \"Adi Gallia\"            \"Saesee Tiin\"           \"Yarael Poof\"          \n[55] \"Plo Koon\"              \"Mas Amedda\"            \"Gregar Typho\"         \n[58] \"Cordé\"                 \"Cliegg Lars\"           \"Poggle the Lesser\"    \n[61] \"Luminara Unduli\"       \"Barriss Offee\"         \"Dormé\"                \n[64] \"Dooku\"                 \"Bail Prestor Organa\"   \"Jango Fett\"           \n[67] \"Zam Wesell\"            \"Dexter Jettster\"       \"Lama Su\"              \n[70] \"Taun We\"               \"Jocasta Nu\"            \"Ratts Tyerell\"        \n[73] \"R4-P17\"                \"Wat Tambor\"            \"San Hill\"             \n[76] \"Shaak Ti\"              \"Grievous\"              \"Tarfful\"              \n[79] \"Raymus Antilles\"       \"Sly Moore\"             \"Tion Medon\"           \n[82] \"Finn\"                  \"Rey\"                   \"Poe Dameron\"          \n[85] \"BB8\"                   \"Captain Phasma\"        \"Padmé Amidala\"        \n\n\nSom du begynner å skjønne er det flere veier til Rom. Klammeparantesen og $ har tildels overlappende funksjoner. De har likevel sine unike bruksområder. De vil vi lære å anerkjenne etter hvert som vi arbeider med dem. En nyttig ting med [] er at vi kan bruke det som et enkelt filter.\n\n# Velg kun de karakterene som er menneske\nstarwars[starwars$species == \"Human\", ]\n\n# A tibble: 39 × 14\n   name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵\n   <chr>        <int> <dbl> <chr>   <chr>   <chr>     <dbl> <chr> <chr>  <chr>  \n 1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…\n 2 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…\n 3 Leia Organa    150    49 brown   light   brown      19   fema… femin… Aldera…\n 4 Owen Lars      178   120 brown,… light   blue       52   male  mascu… Tatooi…\n 5 Beru White…    165    75 brown   light   blue       47   fema… femin… Tatooi…\n 6 Biggs Dark…    183    84 black   light   brown      24   male  mascu… Tatooi…\n 7 Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon\n 8 Anakin Sky…    188    84 blond   fair    blue       41.9 male  mascu… Tatooi…\n 9 Wilhuff Ta…    180    NA auburn… fair    blue       64   male  mascu… Eriadu \n10 Han Solo       180    80 brown   fair    brown      29   male  mascu… Corell…\n# … with 29 more rows, 4 more variables: species <chr>, films <list>,\n#   vehicles <list>, starships <list>, and abbreviated variable names\n#   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld\n\n\nDette er noe knotete: Du må gjengi datasettnavnet inni klamma, og du må huske på kommaet for å implisitt velge alle rader. Dessuten vil du bare få treff på nøyaktig det samme. Hvis noen har en species som er skrevet f.eks. human eller human/alien vil vi ikke få treff. Hvis det bare hadde fantes en smartere implementering av dette filteret …\nOg det gjør det! I, nettopp, tidyverse! \nPå tampen, noen nyttige digresjoner."
  },
  {
    "objectID": "grunnleggende.html#digresjoner",
    "href": "grunnleggende.html#digresjoner",
    "title": "4  Det grunnleggende",
    "section": "5.2 Digresjoner",
    "text": "5.2 Digresjoner\n\n5.2.1 Navngitte lister/vektorer\nVi returnerer til lister og vektorer. Tenk på de vi lagde tidligere:\n\nvektor1\n\n[1] 1 2 3\n\nliste1\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"B\"\n\n[[3]]\n[1] 3\n\n[[4]]\n[1] \"D\"\n\n[[5]]\n[1] 5\n\n\nDe er enkle. Kan vi gjøre dem … mer komplisert? Så klart. Noe som ofte vil være nyttig for oss er det å bruke navngitte vektorer eller lister (named vector/named list). Hva er det? Det er en vektor eller liste hvor hvert element har et navn. La oss se noen eksempler. (Jeg viser bare for vektorer, men det samme gjelder for lister.)\n\nnavngitt_vektor <- c(\"navn\" = \"Arnold\",\n                     \"hilsen\" = \"hey\",\n                     \"venn\" = \"Gerald\")\n\n# Nå har hvert element i vektoren et navn\nnavngitt_vektor\n\n    navn   hilsen     venn \n\"Arnold\"    \"hey\" \"Gerald\" \n\n# Sammenlikn med den tidligere, navnløse vektoren. \nvektor2\n\n[1] \"A\" \"B\" \"C\"\n\n# Vi kan også bruke funksjonen `setNames()` til å gi navn. Nyttig hvis vi har\n# navna lagra i en annen vektor/liste\nnavn <- c(\"Første\", \"Andre\", \"Tredje\")\n\nsetNames(vektor2, navn)\n\nFørste  Andre Tredje \n   \"A\"    \"B\"    \"C\" \n\n# Men --- hvor har navna våre blitt av??\nvektor2\n\n[1] \"A\" \"B\" \"C\"\n\n# Vi må huske å bruke *assignment* for å large det vi gjør\nvektor2 <- setNames(vektor2, navn)\nvektor2\n\nFørste  Andre Tredje \n   \"A\"    \"B\"    \"C\" \n\n\nHvorfor er det nyttig? Navngitte vektorer og lister er nyttig fordi det er mange funskjoner i spesielt tidyverse som nyttiggjør seg av dem. Når man for eksempel bruker rename() til å endre navn på variabler kan man sende en navngitt vektor for å endre mange navn på en gang. Dette gjør at vi mer programmatisk kan endre navn istedenfor å skrive hvert ledd. Når vi har mange ledd, slik som i navn på plansoner og kommunenummer, blir dette svært nyttig.\nForresten, her er en ting jeg ofte brenner meg på: Når du bruker setNames() kommer elementnavna etter elementene. Når du navngir elementene mens du lager vektoren/lista, kommer elemtnnavna først. Du ser det i eksemplene over.\n\n\n5.2.2 Assignment (= og <-)\nKanskje dere føler dere lurt av noe jeg så tidligere.\n\nDerfor bruker jeg alltid <-, og anbefaler deg det også.\n\nOg litt lengre ned viser\n\n# En enkel data frame.\ndat1 <- data.frame(\n  personer = c(\"Luke\", \"Han\", \"Darth\"),\n  moral = c(\"Bra\", \"Nja\", \"Dårlig\")\n)\ndat1\n\n  personer  moral\n1     Luke    Bra\n2      Han    Nja\n3    Darth Dårlig\n\n\nMen her bruker jeg jo = som assignment. Hva skjer?\nPoenget her er at jeg bruker = inni funksjonens argumenter. data.frame() er en funksjon, og jeg definerer her hva som skal være kolonnene i datasettet mitt. Så bruker jeg <- til å assigne det som funksjonen data.frame() returnerer. Forvirra? På generelt grunnlag kan vi si at vi bruker = inni funksjoner, og <- utafor1.\nForresten, hvorfor prøver vi ikke bare å bruke <- inni funksjonen og ser hva som skjer?\n\n# Funker ikke\ndat1x <- data.frame(\n  personer <- c(\"Luke\", \"Han\", \"Darth\"),\n  moral <- c(\"Bra\", \"Nja\", \"Dårlig\")\n)\n\ndat1\n\n  personer  moral\n1     Luke    Bra\n2      Han    Nja\n3    Darth Dårlig\n\ndat1x\n\n  personer....c..Luke....Han....Darth.. moral....c..Bra....Nja....Dårlig..\n1                                  Luke                                Bra\n2                                   Han                                Nja\n3                                 Darth                             Dårlig\n\n\nHvis vi sammenlikner de to datasetta ser vi at det funker … på en måte. Oppsettet blir likt, men vi mister navnet på kolonnene."
  },
  {
    "objectID": "feil.html#glemt-å-laste-inn-en-pakke",
    "href": "feil.html#glemt-å-laste-inn-en-pakke",
    "title": "6  Typiske feil vi (jeg) gjør og hvordan fikse dem",
    "section": "6.1 Glemt å laste inn en pakke",
    "text": "6.1 Glemt å laste inn en pakke\nJeg starter alle R-sesjoner med å laste inn pakker, og jeg laster nesten alltid inn tidyverse. Hvis jeg glemmer det, vil funksjoner fra denne pakka ikke være tilgjengelig."
  },
  {
    "objectID": "feil.html#laster-inn-pakker-i-feil-rekkefølge",
    "href": "feil.html#laster-inn-pakker-i-feil-rekkefølge",
    "title": "6  Typiske feil vi (jeg) gjør og hvordan fikse dem",
    "section": "6.2 Laster inn pakker i feil rekkefølge",
    "text": "6.2 Laster inn pakker i feil rekkefølge\nDet lønner seg å laste inn pakker i omvendt prioritert rekkefølge. Dette er fordi en del pakker inneholder funksjoner med samme navn, men ulik bruksområde. Da vil den siste pakka du laster inn maskere den tidligere funksjonen. For eksempel inneholder stats funksjonen filter(). Denne blir erstatte med dplyrs filter() når vi laster inn den pakka (often via tidyverse). Jeg pleier dermed ofte å laste inn tidyverse sist. Denne feilen er vanskelig å feilsøke, fordi du kan få en feilmelding uten å ha gjort noe som helst endring i koden. (Les: jeg har kasta bort mye tid på å feilsøke når det viste seg at det eneste jeg hadde gjort var å endre rekkefølgene pakkene blei lasta inn på, slik an funksjon jeg var avhengig av fra pakke1 blei bytta ut med en annen funksjon med samme navn fra pakke2.)\nHusk at det går an å bruke en pakkes funksjon uten å laste den inn ved å bruke ::, slik som i dplyr::filter(). Det bidrar til at å unngå at du får lasta inn for mange pakker som overskriver hverandres funksjoner. Spesielt hvis du bare bruker få funksjoner noen få ganger, kan dette lønne seg. Jeg gjør vanligvis dette når jeg importerer datasett, siden dette er noe jeg kun gjør én gang per prosjekt. Hvis jeg derimot skal eksportere mange filer, vil det spare tastaturet mitt å bare laste inn pakka.\nForøvrig har vi en liknende feil"
  },
  {
    "objectID": "feil.html#jeg-har-ikke-gjort-noen-endringer-men-plutselig-funker-ikke-koden-min",
    "href": "feil.html#jeg-har-ikke-gjort-noen-endringer-men-plutselig-funker-ikke-koden-min",
    "title": "6  Typiske feil vi (jeg) gjør og hvordan fikse dem",
    "section": "6.3 “Jeg har ikke gjort noen endringer, men plutselig funker ikke koden min!”",
    "text": "6.3 “Jeg har ikke gjort noen endringer, men plutselig funker ikke koden min!”\nDette er i prinsippet umulig å feilsøke. Heldigvis kan vi benytte oss av et smertelig nyttig prinsipp: Årsaken er alltid at du har gjort en feil.\nDette skjer typisk dersom du har arbeida lenga i en sesjon uten å restarte R. Første gang du restarter R og kjører koden på nytt får du feilmelding. Da er ofte problemet at du på et tidspunkt har lagra noe i miljøet (environment), som ikke lengre er tilstede i koden. Hvis andre deler av koden er avhengig av dette objektet, vil de feile nå som objektet ikke lengre er tilstede. Du må rett og slett finne ut hvor bruddet skjer, og fikse det.\nEn måte å forebygge dette på er ved å ta i bruke functional programming. Det vil si at vi bruker funksjoner i stor grad og sjelden lagrer objekter direkte i miljøet. Brodrigues forklarer det bedre."
  },
  {
    "objectID": "feil.html#sender-et-objekt-via-pipe-til-en-funksjon-som-ikke-er-pipevennlig",
    "href": "feil.html#sender-et-objekt-via-pipe-til-en-funksjon-som-ikke-er-pipevennlig",
    "title": "6  Typiske feil vi (jeg) gjør og hvordan fikse dem",
    "section": "6.4 Sender et objekt via pipe til en funksjon som ikke er pipevennlig",
    "text": "6.4 Sender et objekt via pipe til en funksjon som ikke er pipevennlig"
  },
  {
    "objectID": "feil.html#glemmer-å-bruke-hermetegn-bruker-hermetegn-når-vi-ikke-trenger-hermetegn",
    "href": "feil.html#glemmer-å-bruke-hermetegn-bruker-hermetegn-når-vi-ikke-trenger-hermetegn",
    "title": "6  Typiske feil vi (jeg) gjør og hvordan fikse dem",
    "section": "6.5 Glemmer å bruke hermetegn / bruker hermetegn når vi ikke trenger hermetegn",
    "text": "6.5 Glemmer å bruke hermetegn / bruker hermetegn når vi ikke trenger hermetegn\nHer varierer det nok ut ifra hvor god man er på å forstå strukturer. Jeg gjør denne feilen stadig. Har ikke noe bedre råd enn å alltid prøve begge veier. Det er så klart smart å finne ut av hvorfor man noen ganger bruker hermetegn rundt noe og andre ganger ikke. Essensielt handler det om: Når du bruker hermetegn rundt noe viser du at det er en tekststreng. Når du ikke bruker hermetegn rundt tekst viser du at et er et objekt. Da må objektet finnes i miljøet for at det skal kunne tas i bruk. tidyverse kompliserer dette litt ved at de lar oss henvise til f.eks. kolonnenavn som om de er objekter, f.eks. i:\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.3.6      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\n# Ok\nstarwars %>% \n  select(name)\n\n# A tibble: 87 × 1\n   name              \n   <chr>             \n 1 Luke Skywalker    \n 2 C-3PO             \n 3 R2-D2             \n 4 Darth Vader       \n 5 Leia Organa       \n 6 Owen Lars         \n 7 Beru Whitesun lars\n 8 R5-D4             \n 9 Biggs Darklighter \n10 Obi-Wan Kenobi    \n# … with 77 more rows\n\n# Feilmelding\nstarwars[name]\n\nError in `[.tbl_df`(starwars, name): object 'name' not found\n\n# OK\nstarwars[\"name\"]\n\n# A tibble: 87 × 1\n   name              \n   <chr>             \n 1 Luke Skywalker    \n 2 C-3PO             \n 3 R2-D2             \n 4 Darth Vader       \n 5 Leia Organa       \n 6 Owen Lars         \n 7 Beru Whitesun lars\n 8 R5-D4             \n 9 Biggs Darklighter \n10 Obi-Wan Kenobi    \n# … with 77 more rows\n\n\nDenne kompliseringa godtar vi, for det er så mange fordeler med at tidyverse lar oss henvise direkte til kolonner i datasett som om de var objekter."
  },
  {
    "objectID": "omR.html",
    "href": "omR.html",
    "title": "2  (PART) Part I",
    "section": "",
    "text": "3 Om R\nNoen forskjeller på det å jobbe i R vs. Excel og SPSS.\nR et et kodespråk. Det vil si at vi arbeider gjennom skript fulle av kode. Slik som dette:"
  },
  {
    "objectID": "import-export.html#felles-mønstre",
    "href": "import-export.html#felles-mønstre",
    "title": "5  Import og eksport av data",
    "section": "5.1 Felles mønstre",
    "text": "5.1 Felles mønstre\nImportering og eksportering henger sammen, så vi kan omtale dem samtidig. Det er større forskjell på de ulike formatene vi håndterer, så vi organiserer oss etter dem. Imidlertid er det noen grunnleggende mønstre vi kan diskutere felles.\nDe fleste importeringsfunksjoner kalles noe med read, fordi de leser inn filer. Dermed blir eksporteringsfunksjoner write, fordi de skriver filer til disken.\n\n5.1.1 Filnavn\nVi må ofte definere et navn på fila vi skal skrive eller lese. Når vi leser filer, vil navnet ofte bety både\n\nhva heter fila og\nhvor ligger fila lagra\n\nDette er fordi et filnavn strengt tatt inkludere hele filstien til fila. Den fila jeg arbeider på nå heter f.eks. import-export.qmd. Den ligger på dette filområdet på datamaskina mi: C:/Users/HK2Q/Documents/r/dokumentasjon. Dermed blir det egentlige navnet på fila: C:/Users/HK2Q/Documents/r/dokumentasjon/import-export.qmd. Husk at også filtutvidelsen (det som kommer ettter .) er en del av filnavnet! Når en funksjon ber om file eller path betyr dette ofte at de vil ha hele det fulle filnavnet inkludert filsti.\n\n\n5.1.2 Relative fillokasjoner\nMan kan alltids henvise til konkrete områder på maskina, men dette er optimalt fordi det gjør at du aldri kan flytte noen filer igjen. Dessuten vil ikke koden funke på en annen persons PC med mindre de har 100 % likt oppsett på deres maskin. Derfor er det nyttig med relative filstier. Når du arbeider i Rstudio (og du er ikke en gærning som arbeider i R GUI, er du vel?) forventes det at du arbeider i såkalte prosjekter. Alle mine prosjekter ligger kopiert på M:-disken. Et prosjekt er en mappe med visse filer i seg, hvorav den viktige fila er prosjekt_navn.Rproj. Denne opprettes automatisk når du lager et prosjekt via Rstudio. Det er mange flotte ting med prosjekter, og en av dem er at alle filstier defineres ut fra prosjektets rotmappe. Rotmappa er den mappa hvor .Rproj-filer ligger, og der du putter alle mapper og filer assosiert med prosjektet. Når du arbeider i prosjekter trenger du ikke definere hele filstien til en fil, bare hvor den ligger i forhold til rotmappa. F.eks. har jeg for denne boka lagt alle bilder i en mappe som heter img. Hvis jeg vil henvise til et bilde skrive jeg bare img/bilde.png. Gjør det til en vane å bruke relative filstier når du kan!\nDet går så klart ikke alltid. Når noe ligger på f.eks. M:-disken må jeg lage en full filsti. Fordelen er at M: er en delt disk, så jeg kan anta at filstien vil se likt ut for andre.\nMerk at i noen tilfeller brytes antakelsen om at filstien alltid er relativt til rotmappa. I disse tilfellene er pakka here svært nyttig. Den er også nyttig på grunn av noe annet, nemlig skråstrekproblematikken\n\n\n\n5.1.3 Skråstreker til besvær\nI Windows brukes denne skråstreket \\ til å indikere ei mappe. I alle UNIX-baserte operativsystemet og programmer brukes /. Eksempler på sistnevnte er Ubuntu, macOS, og R. Når vi arbeider med R på Windows skjer det dermed en del arbeid i kulissene når vi henviser til en filplassering. Dette blir åpenbart for oss når vi for eksempel forsøker å lime inn en filsti fra Windows explorer (filutforskeren). R godtar ikke uten videre “feil” skråstrek. Det er to løsninger på dette:\n\nendre skråstrekene så de går andre vei\nescape skråstrekene\n\nDet siste innebærer å bruke det som kalles escape characters. En del tegn har meninger i koden. F.eks. betyr # kommentar i et R-skript. Hvis jeg vil skrive ut emneknaggen, må jeg legge på en escape character så R skjønner at dette tegnet skal ikke skal tolkes slik det vanligvis tolkes. Hva er escape-tegnet? Det er nettopp \\. For å escape # skriver vi dermed \\#, og for å escape \\ skriver vi altså \\\\. \n\n# Ok\n\"C:/Users/HK2Q/Documents/r/dokumentasjon\"\n\n# Ikke ok\n\"C:\\Users\\HK2Q\\Documents\\r\\dokumentasjon\"\n\n# Ok\n\"C:\\\\Users\\\\HK2Q\\\\Documents\\\\r\\\\dokumentasjon\"\n\nEn kjapp måte å få skråstrekene etter å ha kopiert en filsti i Windows er følgende\n\n# Skriver ut filsti med esaped `\\` til konsollen. Funksjonen leser \n# innholdet i utklippstavla og limer det inn i konsollen.\npaste0(readClipboard())\n\nAlt dette for å si: here pakka løser en del av problema våre. Les mer om den på Ode to the here package.\n\n\n5.1.4 Tegnkoding\nSpesielt når det kommer til norske .csv-filer hender det vi får et problem med tegnkodinga (character encoding). En full gjennomgang blir for omfattende. Det holder å si at, igjen, dette er hovedsaklig et Windows-problem. Ideelt sett vil vi ha alt over i unicode (UTF-8). Noen filer er lagra i et annet format. Gjerne ISO8859-1 som er en av standardene som gir oss skandinaviske tegn. En forkludrende faktor er at det tidvis (og inntil ganske nylig, per 2023-03) har vært problemer med R og/eller Rstudio når det kommer til tegnkoding. Disse blir fiksa med tida og er kanskje allerede fiksa. Du ser problemet dukke opp dersom du forventer å se en æ. ø eller å i outputen og istedet får noe sånt som \"\\xe6\\xf8\\xe5\", Ã¦Ã¸Ã¥ eller <U+00C6>. Der er mange ulike faktorer som kan være årsak til dette problemet. En av dem kan være at du må sette tegnkoden spesifikt når du leser en fil. I noen av eksemplene mine vil du set at jeg har spesifisert encoding, og da er det derfor."
  },
  {
    "objectID": "import-export.html#tekstfiler-csv-med-familie",
    "href": "import-export.html#tekstfiler-csv-med-familie",
    "title": "5  Import og eksport av data",
    "section": "5.2 Tekstfiler (csv med familie)",
    "text": "5.2 Tekstfiler (csv med familie)\nVi kan bruke read.csv() fra utils, en av pakkene som lastes når vi starter R. Det finnes også noen funksjoner fra readr, en del av, 100 poeng til den som gjetter rett, tidyverse. Herfra får vi read_csv(), read_csv2(), read_tsv() og read_delim(). Les dokumentasjon for å finne mer informasjon om dem. Kort fortalt er forskjellen at alle tre er implementeringer av den mer generelle _delim(). La oss skrive en fil og deretter last den inn.\n\n# Dette datasettet ligger klart når vi laster inn R.\nmtcars\n\n# La oss lagre det som en csv-fil\nmtcars %>% \n  write_csv(file = here(\"data\", \"mtcars.csv\"))\n\n\n# Og så laster vi den inn igjen\nbiler <- read_csv(file = here(\"data\", \"mtcars.csv\"), name_repair = \"universal\")\n\nRows: 32 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (11): mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nbiler\n\n# A tibble: 32 × 11\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# … with 22 more rows\n\n\nJeg foretrekker readrs funksjoner fordi de har mange nyttige alternativer slik som name_repair = \"universal\". Denne passer på at navna i datasettet er på et format som R tolererer. F.eks. at de ikke har mellomrom i seg. Veldig nyttig. Med na = kan du fortelle R hvordan missing er lagra i fila du importerer."
  },
  {
    "objectID": "import-export.html#spss",
    "href": "import-export.html#spss",
    "title": "5  Import og eksport av data",
    "section": "5.3 SPSS",
    "text": "5.3 SPSS\nFor SPSS-filer bruker vi pakka haven. Denne pakka er en del av … ja, du skjønner.\n\nlibrary(haven)\n# Lagrer en fil som en spss-fil. (Jeg lagrer bare de første fire kolonnene).\nstarwars %>% \n  select(1:4) %>% \n  write_sav(here(\"data\", \"starwars.sav\"))\n\n\n# Les inn en spss-fil\nstjernekrig <- read_sav(here(\"data\", \"starwars.sav\"), .name_repair = \"universal\")\nstjernekrig %>% head()\n\n# A tibble: 6 × 4\n  name           height  mass hair_color   \n  <chr>           <dbl> <dbl> <chr>        \n1 Luke Skywalker    172    77 \"blond\"      \n2 C-3PO             167    75 \"\"           \n3 R2-D2              96    32 \"\"           \n4 Darth Vader       202   136 \"none\"       \n5 Leia Organa       150    49 \"brown\"      \n6 Owen Lars         178   120 \"brown, grey\"\n\n\nLegger du merke til noe med fila over? Hva om jeg printer ut de tilsvarende kolonner fra det opprinnelige datasettet vårt?\n\nstarwars %>% \n  select(1:4) %>% \n  head()\n\n# A tibble: 6 × 4\n  name           height  mass hair_color \n  <chr>           <int> <dbl> <chr>      \n1 Luke Skywalker    172    77 blond      \n2 C-3PO             167    75 <NA>       \n3 R2-D2              96    32 <NA>       \n4 Darth Vader       202   136 none       \n5 Leia Organa       150    49 brown      \n6 Owen Lars         178   120 brown, grey\n\n\nHårfarge har mista NA-designasjonen. Nå er de som før var missing bare tomme. Dette kan skape hodebry for oss seinere, så det er bra vi oppdaga det nå.\nFor å være helt ærlig er jeg ikke sikker på hvordan man løser dette direkte. Feilen oppstår enten når vi eksporterer til .sav eller importerer tilbake til R. Kanskje finnes det et svar i Havens dokumentasjon. Imidlertid er det lett å omgå problemet i ettertid:\n\n# Lag ny versjon av hårfarge. Hvis hårfarge er tom (\"\"), bli missing. Ellers, \n# bli det du allerede er. \nstjernekrig <- stjernekrig %>% \n  mutate(\n    hair_color = if_else(\n      hair_color == \"\", \n      NA_character_, \n      hair_color)\n    )\nstjernekrig %>% head()\n\n# A tibble: 6 × 4\n  name           height  mass hair_color \n  <chr>           <dbl> <dbl> <chr>      \n1 Luke Skywalker    172    77 blond      \n2 C-3PO             167    75 <NA>       \n3 R2-D2              96    32 <NA>       \n4 Darth Vader       202   136 none       \n5 Leia Organa       150    49 brown      \n6 Owen Lars         178   120 brown, grey\n\n\nHvorfor NA_character_ og ikke bare NA? if_else forventer at alle argumentene skal være av samme type/klasse. Derfor må til og med NA være en spesiell type NA. Siden hair_color er en strengvektor, må NA være en streng-NA.\nNår vi laster inn SPSS-filer vil vi ofte få med merkelappene (labels) derfra også, i form av attributter. tidyverse-pakker talker ofte dette og viser dem når vi printer objektene. Noen ganger har jeg opplevd, med andre pakker, at attributtene ikke kan leses. I så fall kan man bare fjerne dem."
  },
  {
    "objectID": "feil.html#feil-skråstrek",
    "href": "feil.html#feil-skråstrek",
    "title": "6  Typiske feil vi (jeg) gjør og hvordan fikse dem",
    "section": "6.6 Feil skråstrek",
    "text": "6.6 Feil skråstrek\nWindows vs. mac"
  },
  {
    "objectID": "feil.html#tegnkode",
    "href": "feil.html#tegnkode",
    "title": "6  Typiske feil vi (jeg) gjør og hvordan fikse dem",
    "section": "6.7 Tegnkode",
    "text": "6.7 Tegnkode\n\nOfte hjelper det å restarte R-sesjonen."
  },
  {
    "objectID": "import-export.html#excel",
    "href": "import-export.html#excel",
    "title": "5  Import og eksport av data",
    "section": "5.4 Excel",
    "text": "5.4 Excel\nJeg er unødvendig streng mot Excel fordi jeg gjerne vil ha ut en enkel datastruktur fra Excels filer, mens Excel tillater oss kompliserte strukturer som ikke uten videre kan puttes inn en en vanlig tabell. Som sagt er vi her avhengig av den enkelte person som lagde Excelfila når det kommer til hvor lett det er for oss å laste den inn. Det å være konsekvent er viktigere enn å etterlikne en “vanlig tabell”. Til dette arbeidet har vi to pakker som har ulike bruksområder:\n\nopenxlsx: Kilde. Brukes for å skrive Excel-filer.\nreadxl: Kilde. Brukes for å lese Excel-filer.\n\n\n5.4.1 Skrive til Excel: openxlsx\nPakkas egen introduksjon er en god guide til hvordan dette funker. Sjekk den ut. I korte drag:\n\nlibrary(openxlsx)\n\n# Kjapp lagring av fil\nstarwars %>% write.xlsx()\n\n# Hvis du vil ha det som en tabell \nstarwars %>% write.xlsx(asTable = TRUE)\n\nHer ser vi forøvrig en demonstrasjon av hvordan et argument er valgfritt fordi det er definert en default-verdi. I definisjonen av write.xlsx() står det at argumentet asTable er satt til FALSE. Dermed trenger vi ikke spesifisere dette med mindre vi vil endre den til noe annet, slik vi gjør i siste linje.\nMan kan også bygge opp en excelfil mer gradvis\n\nlibrary(openxlsx)\n\n# Start med å lage et workbook-objekt\nwb <- createWorkbook()\n\n# Legg til (tomme) arkfaner\naddWorksheet(wb, sheetName = \"Motor Trend Car Road Tests\", gridLines = FALSE)\naddWorksheet(wb, sheetName = \"Iris\", gridLines = FALSE)\n\n# Skriv data til disse arkfanene. `mtcars` og `iris` er datasett som ligger i R.\nwriteDataTable(wb, sheet = 1, x = mtcars, colNames = TRUE, rowNames = TRUE, tableStyle = \"TableStyleLight9\")\nwriteDataTable(wb, sheet = 2, iris, startCol = \"K\", startRow = 2)\n\n# Lagre fila som excel-fil.\nsaveWorkbook(wb, here(\"data\", \"basics.xlsx\"), overwrite = TRUE)\n\nDette lar deg spesifisere flere av de grafiske elementa i excel-fila, blant annet.\nEn apropos, dersom du har mestra pipa (%>%): Man kan ikke uten videre pipe sammen de forskjellige kommandoene i denne pakka slik man kan med datasett. Dette gir feil:\n\n# Start med å lage et workbook-objekt\nwb <- createWorkbook()\n\n# Legg til (tomme) arkfaner\naddWorksheet(wb, sheetName = \"Motor Trend Car Road Tests\", gridLines = FALSE) %>% \n  addWorksheet(sheetName = \"Iris\", gridLines = FALSE)\n\nError: wb must be a Workbok\n\n\nHer ser vi altså en begrensing ved tidyverse: Når du bruker pakker som ikke er en del av universet deres kan vi måtte gjøre endringer i arbeidsflyten vår.\n\n\n5.4.2 Lese Excel-filer: readxl\nDenne pakka er en del av tidyverse, så her er det bare å stappe pipa.\nLa oss ta et steg tilbake og tenke på vi må gjøre når vi leser inn Excel-filer. Det er en del konsepter i Excel som ikke finnes eller brukes i R:\n\ntomme rader og kolonner som rammer: Det vi ser som en tom celle i Excel er ikke nødvendigvis at den eksisterer. La oss ikke bli for filosofisk her. Pakkas tekst om regnearkgeometri forklarer dette bedre enn jeg kan.\nfarger som indikerer et eller annet om en rad, kolonne eller celle: Dette pleier jeg se bort fra. Viktig informasjon om rader kan heller lagres i tekstformat, i f.eks. en .Rmd/.qmd-fil.\nfunksjoner: i R definerer vi funksjonene og kjører dem en gang. Funksjonene blir liggende som objekter i miljøet/skriptet, mens verdiene de produserer blir putta i datasettet. I Excel blir funksjonen og resultatet liggende i samme celle, oppå hverandre. Når vi laster inn fila er vi bare interessert i sjølve resultatene av funksjonen heller enn funksjonen i seg sjøl.\nsammenslåtte celler: Disse er spesielt vanskelig. Ifg. denne posten på StackOverflow kan man bruke openxlsx for å lese slike filer. Hvis det gjelder noen få celler, f.eks. i overskrifter, ville jeg vurdert å heller manuelt gå inn og dele dem opp igjen.\n\nVi kan bruke read_excel() fra readxl til å lese inn Excel-filer. Den lar oss definere en hel del nyttige ting. Her har jeg limt inn funksjonen med alle argumentene, så forkalrer jeg i en kommentar hva de gjør\n\nlibrary(readxl)\n\nread_excel(\n  path, # Filsti + navn på fila du skal lese\n  sheet = NULL, # Hvilke(t) regneark. Enten navn eller indeks\n  range = NULL, # Celler du vil lese. I Excels format, f.eks. \"B3:D87\"\n  col_names = TRUE, # Er første linje kolonnenavn?\n  col_types = NULL, # Definer hvilke klasser/typer hver kolonne skal lagres som\n  na = \"\", # Hvis NA er lagra som noe annet enn en tom celle, skriv det her\n  trim_ws = TRUE, # Automatisk fjerning av whitespace\n  skip = 0, \n  n_max = Inf,\n  guess_max = min(1000, n_max), # Se ned\n  progress = readxl_progress(),\n  .name_repair = \"unique\" \n)\n\nOm guess_max: Hvis du ikke definerer col_types vil funksjonen gjette på hvilken type data hver kolonne inneholder. På generelt plan er Excel god på dette. Den sliter hvis:\n\nei kolonne inneholder flere enn en type og\ndet er mange tomme celler i starten av ei kolonne\n\nDet står mer om gjettinga i Cell and Column Types. Angående punkt 2: dette var et problem i barnehagekapasitetsarbeidet. Her lasta jeg inn noen områder i ei Excel-fil som hadde mange tomme rader før det dukka opp en verdi. I disse tilfellene kunne jeg få feilmelding fordi funksjonen forventa en annen type verdi enn det den fant. Løsninga blei å spesifisere kolonnetypen med col_types."
  }
]